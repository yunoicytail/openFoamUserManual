### 27  Other mesh manipulation tools

#### 27.1 transformPoints

The tool transformPoints can be used to scale, translate or rotate the points a mesh. Section 29.3.4 contains a case in which this tool can be useful.

##### 27.1.1 Rotation

Rotating the geometry can be specified in two ways.

**Using two vectors**

Here, the rotation is defined by providing a vector before and after the rotation. From these two vectors, the transformation matrix can be computed

**Yaw, Pitch and Roll**

There are actually two options: rollPitchYaw and yawPitchRoll. Here, the rotation is defined by specifying three angles in degrees, which are subsequently applied to the x-axis, the y-axis and the z-axis.

#### 27.2 topoSet

The tool topoSet creates point, face or cell sets from a geometric definition. There are a number of ways to define the geometric region containing the intended points, faces or cells.

##### 27.2.1 Usage

The dictionary topoSetDict is used to define the geometric region. Find some examples in the tutorials using the following command.

```
find $FOAM_TUTORIALS - name topoSetDict
```
Listing 151: Find examples for the use of topoSet

##### 27.2.2 Life hack: apply topoSet on decomposed cases

The tool topoSet can be applied to decomposed cases, by running the tool in parallel in the same fashion as we would run a solver in parallel.

```
mpirun - np 4 topoSet - parallel
```
Listing 152: Run topoSet in parallel, i.e. apply topoSet on a decomposed case

This will apply all definitions for the creation of sets and zones to the sub-domains of the decomposed case.

This can also be done with cases that are currently running, e.g. as a long-duration simulation is running, we are preparing sets and zones for the subsequent post-processing. However, if we apply topoSet on a case, which is at that time being simulated, we need to take extra care not to alter, remove or mess in any other way with already existing sets or zones.

The sets and zones we created for the sub-domains of the decomposed case need to be reconstructed, so that they are present when the case is finished, and the subsequent post-processing is done on the reconstructed case. We can reconstruct sets and zones, which were created with the decomposed case, by calling reconstructPar with the -constant command line argument.

##### 27.2.3 Pitfall: The definition of the geometric region

To demonstrate the function of topoSet a cell set was defined for the cavity tutorial-case. The mesh of the cavity case is 1×1×0.1 m and the box defining the cell set was chosen to be 0.5×0.5×0.05 m. The dimensions of this box are simply half the dimensions of the mesh. However, only cells whose cell centre is located in the box are contained in the cell set. As the mesh is one cell in depth and 0.1 m in depth, all the cell centres are exactly at z = 0.05 m. Due to inevitable numerical errors in calculating the cell centre62, the numerical errors decided whether a cell was included into the cell set or not.

To avoid this error, always make sure the geometric region contains all the intended cells.

![图像55](images/54.PNG)\
Figure 55: A faulty cell set definition. The red cells are part of the cell set. All other cells are blue.

##### 27.2.4 Pitfall: the face-normal of internal faces

For simulations with run-time post-processing, we might need sets of internal faces, e.g. for extracting the pressure at certain cross-sectional planes. With topoSet we can create sets of internal faces by using the using the boxToFace source to select all faces in a slice of geometry, and the normalToFace source to select all faces with a face-normal parallel to the normal of the cross-sectional plane in question, and finally perform a boolean operation to eliminate all faces not oriented parallel to the cross-sectional plane.

While this procedure requires a bit of trail-and-error to determine the proper size of the box to include only a single layer of faces parallel to the cross-sectional plane, the procedure is generally appropriate for the task in question. However, there is one flaw in the discussed procedure: the orientation of the face-normal vectors of internal faces.

If we imagine a pipe with its principal axis parallel to the x axis, then the internal faces we need for our cross-sectional plane have their face-normals oriented parallel to the x axis. However, the face-normals of the internal faces may point into the positive x direction or into the negative x direction. Thus, our procedure from above needs to be extended by a second use of the normalToFace source, this time with the opposite normal vector.

##### 27.2.5 Legacy pitfall: renumbered mesh

At the point of writing, using OpenFOAM-2.something, the utility renumberMesh does not consider cell sets. If renumberMesh is called after cell sets were created by topoSet, the cell set is invalid. The reason for this is, that the cell labels of the cell set remain unchanged as renumberMesh completely relabels the mesh. Thus, the cell set still exists and the number of cells is unchanged, however, as other cells bear the labels of the original members of the cell set, the cell set is invalid.

To resolve this problem, topoSet needs to be run after renumberMesh. This even works in parallel, when the case has been decomposed.

#### 27.3 setsToZones

The utility setsToZones serves the purpose to:

Add pointZones/faceZones/cellZones to the mesh from similar named pointSets/faceSets/cellSets[50].

This utility is needed when we create some cellSets which we later want to use e.g. with a functionObject (the cellSource functionObject acts on all cells or on a cellZone). cellSets can be created with topoSet. After we ran topoSet we simply run setsToZones without any further parameters or providing a dictionary. setsToZones creates cellZones which contain the same cells as the corresponding cellSets.

#### 27.4 refineMesh

The tool refineMesh is used – just as the name suggests – to refine a mesh.

##### 27.4.1 Usage
First a cell set has to be defined, this can be done using the tool topoSet.
With the dictionary refineMeshDict the rules for refining a particular cell set can be stated. When rules have been defined in refineMeshDict , then the command line option -dict has to be used.

![图像56](images/55.PNG)\
Figure 56: An example of a refined mesh. The refined region is marked in red.

##### 27.4.2 Pitfall: no command line parameters
If the tool refineMesh is called without any command line parameters then the whole mesh is refined. For refineMesh to obey the rules set in the refineMeshDict the command line option -dict has to used when calling refineMesh. See this useful post in the CFD-Online Forum http://www.cfd-online.com/Forums/openfoam-meshing-utilities/61518-blockmesh-cellset-refinemesh.html#post195725

Notice the different meaning of the -dict command line option of the tools topoSet and refineMesh. If you are in doubt about this difference, check the summary of the command line usage printed by the -help option.

#### 27.5 refineWallLayer

refineWallLayer is a tool to refine cells that are adjacent to a set of user-specified patches.

##### 27.5.1 Control
The list of patches is provided by the user via a command line argument. The next argument is the edge fraction, which is to be applied in the refinement. Listing 153 shows an example of how this tool is called. The list of patches and the edge fraction are mandatory arguments.

```
refineWallLayer - overwrite ( top bottom sideLeft ) 0.4
```
Listing 153: Invoking refineWallLayer for the cells adjacent to three patches.

Figures 57, 58 and 59 show the results of a successive application of this tool along with the base mesh. In this case, the patch of the inner void is refined. Figures 58 and 59 show the treatment of sharp, concave edges. Figure 60 shows the result of refineWallLayer when the cells belonging only one patch are refined.

![图像57](images/58.PNG)\
Figure 57: The base mesh for the wall layer refinement.

![图像58](images/57.PNG)\
Figure 58: Applying the wall layer refinement once.

![图像59](images/56.PNG)\
Figure 59: Applying the wall layer refinement a second time.

![图像60](images/61.PNG)\
Figure 60: Applying the wall layer refinement twice on the horizontal patch at a concave edge.

Figures 61 and 62 show how refineWallLayer treats convex edges. If the edge is formed by two distinct patches, refineWallLayer can be applied to each patch individually, which leads to a different outcome, compare Figures 61 and 63.

![图像60](images/61.PNG)\
Figure 61: Applying the wall layer refinement twice on both patches of a convex edge.

![图像62](images/59.PNG)\
Figure 62: Applying the wall layer refinement twice on one patch of a convex edge.

![图像63](images/62.PNG)\
Figure 63: Applying the wall layer refinement successively on two patches of a convex edge. This approach leads to a different outcome than the one shown in Figure 61.

#### 27.6 renumberMesh  
##### 27.6.1 General information
The tool renumberMesh modifies the arrangement of the cells of the mesh in order to create lower bandwidth for the numerical solution. For further information about the role and the influence of the bandwidth in numerical simulation see books on the numerical solution of large equation systems, e.g. [35].

Renumbering the mesh can reduce computation times as it re-arranges the data to benefit the numerical solution of the resulting equation system. The benefit of renumbering the mesh strongly depends on several factors. However, testing is recommended.

Renumbering the mesh even has an effect at the simplest possible simulation case – the cavity case of the tutorials. This mesh consists of a single block and it is quasi 2D (i.e. it is only 1 block in depth). The mesh resolution was chosen to 40 × 40 × 1, resulting in 1600 cells. icoFoam was run for 10 s. Execution time was reduced by renumberMesh from 6.18 s to 6.08 s.

A simulation with a mesh consisting of 120000 cells defined by 9 blocks was run for 5 s of simulated time with twoPhaseEulerFoam. Execution time was reduced by renumberMesh from 9383.81 s to 9273.13 s.

Even though the reduction of execution time is small in this examples, this reduction comes at no cost. Running renumberMesh takes little time and at run-time of the simulation no additional work has to be done.

![图像63](images/53.PNG)\
Run renumberMesh before any other tools which generate sets or zones. Why the order of execution of certain tools is significant is explained in Section ?? on a case which went slightly wrong.

##### 27.6.2 Background
The discretized finite volume problem results in a linear equation system, which is usually expressed in matrixform.  
Ax = b (31)  

The vector x contains the field values at the cell centers. The matrix A contains non-zero elements for each pair of neighbouring cells. This is a consequence of our assumption that only adjacent cells interact. If we used some sort of higher order discretisation or interpolation, we might get into a situation where also second neighbours interact. However, for sake of ease, we limit ourselves in this discussion to direct neighbours.

Regardless of our computational mesh being one-, two- or three dimensional, we label all cells with positive ascending integers. Thus, we can store the values of a scalar field into a vector. The number of elements of this vector (N) is equal to the number of cells in our domain. Consequently, the matrix A is of the size N × N. However, as only adjacent cells interact, most of the elements of A will be zero-entries.

If the cells with the labels i and j are adjacent, then the elements aij and aji of A will be non-zero. Since we focus on the general structure of A we do not care whether aij equals aji, or if both of them are actually non-zero.

The arrangement of the cells – or, to be more precise, the labelling – has a strong impact on the structure of the matrix A, i.e. the distribution of the non-zero elements.

**A simple example**
Here we examine the effect of cell labelling with a very simple example. Figure 64 shows a simple mesh with 8 cells. Two different cell labelling schemes are indicated by the numbers inside the cells.

In Figure 65 we see the connections between the cells depicted as a graph. A N × N matrix can be from the interaction perspective seen as a graph with N nodes. An edge between the nodes i and j represents the non-zero elements aij and aji.

![图像64](images/27-fig64.png)\
Figure 64: A simple mesh with 8 cells and different cell labelling schemes.

![图像65](images/27-fig65.png)\
Figure 65: The connectivity graph of our mesh.

Figure 66 shows the corresponding matrix structure. The labelling scheme on the right hand side of Figures 64 and 65 results in a matrix with a lower bandwidth.

![图像66](images/27-fig66.png)\
Figure 66: The matrix structure. A * denotes a non-zero element. Notice the lower bandwidth of the matrix on the right hand side. The number of zero-entries is equal, however, the different distribution leads to a different numerical behaviour.

##### 27.6.3 Pitfall: sets and zones will break my bones

The use of renumberMesh carries a certain risk. In simulation cases which make use of tools like topoSet and renumberMesh, the order in which those tools are invoked is of importance. Update: This has been resolved at some point. In OpenFOAM-4.0 this is no issue any more.

The reason behind this, is the way OpenFOAM stores its mesh information. The only actual geometric information is stored in the list of points in the file constant/polyMesh/points. The faces are defined via the point labels of the points defining the mesh. Thus, if the points Pk, Pm, Puand Pw define a face, then the entry in constant/polyMesh/faces for this very face reads (k m u w). The same principle applys for the definition of cells. There, the labels of the faces defining the cell are stored. This way, no redundant information is stored. If we define a cellSet with topoSet e.g. all cells within a certain geometrical region we simply store the cell labels of all cells for which the condition is fulfilled. Thus, if we now run renumberMesh, we shuffle the cells within the mesh. No actual change is applied in the mesh, however, the cell with the label A which was at the location (xA, yA, zA) before renumbering, may or most certainly will be at location (xB, yB, zB) with B = A after renumbering.

Figure 67 shows the simulation domain of an aerated stirred tank. The red cells are part of a cellZone on which source terms using the fvOptions mechanism act65. A run of renumberMesh after the cellZone was created caused the cellZone to get scrambled. However, the simulation worked nontheless and yielded some unexpected results.

![图像67](images/27-fig67.png)\
Figure 67: Left: The cut-away of the walls of a stirred tank with the rotor (blue) and the aeration device (red). The aeration device is a cellZone on which source terms are applied via the fvOptions mechanism in OpenFOAM-2.3.x. Right: The stirred tank was simulated using parallel processes. After decomposing the domain, a parallel renumbering of the mesh was conducted. Renumbering the subdomains scrambled the cellZone within their respective subdomains. The transparent iso-volume shows the gas-phase volume fraction 0.25 s into the simulation. The cells of the cellZone act as source for the gas-phase, although not on their original location.

##### 27.6.4 Life-hack: converting mesh (and fields) from binary to ASCII
You may run into a situation, my dear reader, when you might need to convert the mesh data of your OpenFOAM case from the binary format into the ASCII format, or vice-versa. What we need in this situation is a tool, which reads and writes the mesh, and renumberMesh is just the tool we need66. In this case, we simple use to tool for its I/O, and not for its actual use, i.e. re-ordering the mesh to improve numerical solutions.

One such occasion of the former need, i.e. convert a mesh from binary to ascii, is when you want to use tools of several OpenFOAM-variants, e.g. the checkMesh utility tool of foam-extend-4.0 can not read a mesh in binary format, which was created by a mesh conversion tool (such as fluentMeshToFoam) of OpenFOAM-6. For some reason, the binary formats of foam-extend and OpenFOAM (foundation release) are not compatible. However, foam-extend is perfectly happy with meshes written by OpenFOAM in ASCII format. This, rather lengthy prelude, leads us a use-case of the tool renumberMesh, which might be considered harmless abuse: use the tool to change the format the mesh is stored on disk.

The procedure is rather simple:

1. Create a new case directory, in which the conversion should take place  
2. Copy the relevant folders, i.e. constant and system, into this new case directory. Also copy time step folders, if necessary.  
3. Change the writeFormat setting in system/controlDict from binary to ascii.  
4. Run renumberMesh -overwrite  

Now, all the mesh-files, such as points or faces, are stored on disk in ASCII format.

**A note on converting fields**

As renumberMesh is not a classical pre- or post-processing tool for the case’s solution data, there is no option to renumber all fields present in a case. Hence, only one time step is subject to renumbering. This is generally the lowest time step.

![图像68](images/27-fig68.png)\
Figure 68: Renumbering the solution of the cavity case: the case was run, and all time steps prior to 0.3 were deleted. Then renumberMesh -overwrite was run. As 0.3 was the first time step, the fields in the time step 0.3 were renumbered along with the mesh. The later time steps, however, were left untouched.

Thus, if you want to convert a case with mesh and fields from binary to ASCII format, simply create a copy of the case with one time step only, and perform the renumbering. The tool renumberMesh only allows the user to specify one specific time, yet not a range of times. Thus, we consider it not possible to convert a case with multiple time steps from binary to ASCII, or the other around.

#### 27.7 subsetMesh
subsetMesh is a tool to remove certain cells from a mesh. The tool expects the name of a cellSet as a command line argument. The cells of this cellSet will remain in the resulting mesh, all other cells are removed.

**Pitfall: sets and zones will break my bones**
At the time of writing (OpenFOAM-4.0), subsetMesh does not treat cellSets or cellZones. Thus, when we use subsetMesh to remove large parts of the mesh, then the cellSet may contain cells that are no longer part of the mesh. This error will be felt when the cell indices associated with the cellSet or cellZone are larger than the total number of cells in the mesh. Otherwise, if the cell indices are smaller than the total number of cells, the cellSet might still be valid from OpenFOAM’s point of view, but it may contain different cells.

#### 27.8 createPatch

#### 27.9 stitchMesh

#### 27.10 tetDecomposition

The mesh manipulation tool tetDecomposition is part of the OpenFOAM variant foam-extend68, and there is no comparable tool within the foundation release of OpenFOAM at the time of writing.

This tool takes an OpenFOAM mesh, computes the tet-decomposition and writes the resulting mesh to disk. Figures 69 and 70 illustrate how this tool works. The faces of the initial cell is decomposed into triangles. With such a triangle and the centroid of the cell, a sub-tetrahedron can be created.

Depending on the original mesh, the number of cells of the resulting mesh can rise dramatically. The single tetrahedron of Figure 69 is decomposed into 12 sub-tetrahedra. The initial hexahedron of Figure 70 is decomposed into 24 tetrahedra.

![图像69](images/67.PNG)\
Figure 69: A tet-decomposed tetrahedron: the original tet-cell is outlined in blue, the face-decomposition is outlined in black, and one of the resulting sub-tets is shown in grey.

![图像70](images/69.PNG)\
Figure 70: A tet-decomposed hexahedron: the original hex-cell is outlined in blue, the face-decomposition is outlined in black, and one of the resulting sub-tets is shown in grey.

#### 27.11 decomposePar

The tool decomposePar is used to divide the domain for a parallel simulation run into smaller sub-domains.

##### 27.11.1 Visualize the decomposition

The tool decomposePar has the command-line option -cellDist, which causes decomposePar to write the cell distribution as a field to disk. This cell distribution can then later be re-used with the manual decomposition method, or be visualized using ParaView. For this purpose, decomposePar writes a volScalarField and a labelList with the indices of the sub-domains.

![图像70](images/68.PNG)\
Figure 71: The cell distribution of a multi-region case, with 2 regions and 4 sub-domains for parallel processing. The small region outlined in white is the solid region, the surrounding larger region is the fluid region of this case. Each sub-domain (colour-coded from 0 to 3) is assigned a chunk of each region.

#### 27.12 mirrorMesh
mirrorMesh is, similar to extrudeMesh, a mesh manipulation tool that is somewhere between mesh manipulation and mesh creation. This tool is controlled by entries in the file system/mirrorMeshDict. The set of parameters is quite limited, since we only need to provide a definition for the plane which is to act as the mirror, and a tolerance.

Listing 154 shows an example of a mirrorMeshDict, which consists of a plane definition (here we have three possible methods to choose from), and the tolerance.

```
planeType pointAndNormal ;
// Overall domain boundingBox : (0 0 0) (0.1 0.1 0.01)
pointAndNormalDict
{
basePoint (0.0 0.0 0.01) ;
normalVector (0 0 1) ;
}
// plane equation : ax + by + cz + d = 0
planeEquationDict
{
a 0;
b 0;
c 1;
d -0.01;
}
embeddedPointsDict
{
point1 (0 0 0.01) ;
point2 (1 0 0.01) ;
point3 (0 1 0.01) ;
}
planeTolerance 1e -5;
```
Listing 154: All the possible entries in the file mirrorMeshDict to mirror the initial mesh around an xxy plane with a z-component of z = 0.01.

**Potential pitfall: set and zones may break my bones**

mirrorMesh does not apply the mirroring operation on the existing sets and zones of the mesh. This can be an issue depending on whether an existing cellSet or cellZone needs to be mirrored as well. If this is not necessary, users should remove all sets and/or zones prior to mirroring to avoid confusion.

In Figure 72, we see the result of the following sequence of operations: create the mesh using blockMesh, extrude a patch to grow a number of cell-layers, and finally mirror the mesh. The extrusion operation created the cellSet addedCells, which was not mirrored by mirrorMesh.

![图像72](images/70.PNG)\
Figure 72: A cellSet after running mirrorMesh to mirror the mesh using the x x y plane.

