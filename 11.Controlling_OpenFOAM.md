### 11 Controlling OpenFOAM
#### 11.1 The means of exerting control
Classical UNIX applications know several means of controlling their configuration [^20]:
• System-wide run-control files
    An example for these are files in /etc on Linux or UNIX systems. For OpenFOAM, such system-wide run-control files are located in $FOAM_ETC, which might be home/user/OpenFOAM/OpenFOAM-3.0.0/etc. There, we can find the global controlDict, controlling OpenFOAM’s behaviour installation-wide.
• System-wide environment variables
    Such a system-wide variable on a Linux system is $HOSTNAME, which is the name associated to identify the computer within a network. This name is the same for all users logged in at a certain machine, and it can and should not be changed by a user. For OpenFOAM such system-wide environment variables are $FOAM_ETC, $FOAM_INST_DIR or $WM_THIRD_PARTY_DIR. This variables are equal for all users of a certain installation.
    The distinction between system-wide and user-defined settings blurs, when we install OpenFOAM in our home directory, then we are the administrator and the single user of our installation. This distinction was made for clusters, which provide one installation to many users.
• User-defined run-control files
    A perfect example of a user-defined run-controlled file is the file .bashrc in the user’s home directory. This file contains user-specific settings. During the installation process of OpenFOAM, this file needs to be edited to make the OpenFOAM installation available to the user.
• User-set environment variables
    These aren’t quite common. On a Linux or UNIX system, a user might set the $EDITOR variable, then applications, which might call an editor can simply query this variable to call the preferred editor of the user.
• Switches and arguments passed on the command line
    These are very common. A widely known example are the command line arguments -h, -help or --help for displaying a summary of the application usage.

The order of the above listed means of control is descending from the system-level down to the per-execution level. With the freedom to choose between five mechanisms to control the behaviour of an application comes great responsibility to the software developer to choose wisely. Nobody wants to pass the same, never-changing command line arguments every time an application in run. Otherwise, user often do not have the possibility to edit system-wide run-control files, so these might be a bad location for settings which change on a daily basis.

##### 11.1.1 Variables
Variables are the best place to store information, which is repeatedly needed. E.g. it would make no sense to specify the installation directory of OpenFOAM in every run-control file which needs to know where OpenFOAM is installed on the system, instead a variable $FOAM_INST_DIR is defined in one of OpenFOAM’s global run-control files. In all other run-control files, which need to know the installation path, this variable is used. Thus, information redundancy is avoided. Imagine the poor cluster administrators, if some information were stored in multiple places, and this information were to change. Good luck finding and updating ALL occurances of this data.

Variables offer the freedom to use the same name (i.e. the variable) regardless of what the actual information is. OpenFOAM is always installed at $FOAM_INST_DIR, whether that is /home/user/OpenFOAM, /opt/OpenFOAM or /home/user/Desktop/important_softWare.

##### 11.1.2 Dictionaries
Dictionaries are the run-control files of OpenFOAM. Most of the controls of OpenFOAM are set in so called dictionaries. An important dictionary is the file controlDict. Dictionaries offer a convenient way to store structured information of arbitrary size, which would be rather impossible using variables or command line arguments. Imagine typing all contents of controlDict every time you run a solver.

The distinction between global and local dictionaries saves ourselves from messing up the OpenFOAM installation when fiddling with a case’s set-up.

##### 11.1.3 Command line arguments
Besides the dictionaries, there are also command-line arguments to control certain aspects of OpenFOAM’s solvers and utilities. Command line arguments are the best way to pass information to an application that might change from one run to the other, even when the case is the same. 
An example is the -parallel command line switch. Regardless of whether we run a case with a single process or in parallel, the case’s settings are unchanged. Thus, it would be inconsistent to tell the solver to run in parallel via a case file.

Command line switches are command line arguments, which do not need any additional information. Adding -help to a solver name is sufficient to make the solver display its usage summary. A command line argument, on the other hand, needs additional information. An example is the -time argument used to tell post-processing tools on which time steps to act upon. Passing -time alone without any further information leaves the tool clueless and it will issue an error message.

#### 11.2 Syntax of the dictionaries
The dictionaries need to comply a certain format. The OpenFOAM User Guide states, that the dictionaries follow a syntax similar to the C++ syntax.

    *The file format follows some general principles of C++ source code.*

The most basic format to enter data in a dictionary is the key-value pair. The value of a key-value pair can be any sort of data, e.g. a number, a list or a dictionary.

##### 11.2.1 Keywords - the banana test
As OpenFOAM offers no graphical menus, in some cases allowed entries are not visible at a glance. If a key expects a value of a finite set of data, then the user can enter a value that is definitely not applicable, e.g. banana. Then, OpenFOAM produces an error message with a list of allowed entries.

```
--> FOAM FATAL IO ERROR :
expected startTime , firstTime or latestTime found ’ banana ’
```
Listing 37: Wrong keyword, or the banana test

Listing 37 shows the error message that is displayed when the value banana is assigned to the key startFrom that controls at which time a simulation should start. The error message contains a note that is formated in this way: expected X, Y or Z found ABC.
If in a dictionary several key-value pairs are erroneous, only the first one produces an error, as OpenFOAM aborts all further operations.

**Pitfall: assumptions & default values**
In some cases the banana test behaves differently than expected. Listing 38 shows the warning message OpenFOAM returns, when the banana test is used with the control compression of controlDict. See Section 11.3.2 for a description of this control. In this case, OpenFOAM does not abort but continues to run the case. Instead of returning an error message and exiting, OpenFOAM simply assumes a value in place of the invalid entry.
```
--> FOAM Warning :
From function IOstream :: compressionEnum ( const word &)
in file db / IOstreams / IOstreams / IOstream .C at line 80
bad compression specifier ’ banana ’, using ’ uncompressed ’
```
Listing 38: Failed banana test

##### 11.2.2 Mandatory and optional settings
Some settings are expected by the solver to be made. If they are not present, OpenFOAM will return an error message. Other settings have a default value, which is used if the user does not specify a value. In this sense, settings can be divided into mandatory and optional ones.

As mandatory settings causes an error if they are not set, a simulation can be run only if all mandatory settings were made.

**About errors**
    + There will be an error when mandatory settings were not made.
    + There is no error message if an optional setting (that is necessary) was omitted. All optional controls have a default value and will be in place.
    + There is no error message if a setting was made and that setting is not needed. The solver simply ignores it. Consequently the definition of a variable time step in controlDict does not necessarily mean, that the simulation is performed with variable time steps, e.g. if icoFoam (a fixed time step solver) is used.
    + Sometimes an error message points to the setting of a keyword that is actually not faulty. See Section 11.2.3.
	
See Section 57.3 for a detailed discussion – including a thorough look at some source code – about reading keywords from dictionaries.

##### 11.2.3 **Pitfall: semicolon (;)**
Similar to C++, lines are terminated by a semicolon. Listing 39 shows the content of the file U1 in the 0 - directory. The line defining the boundary condition (BC) for the outlet was not terminated properly. Listing 40 shows the provoked error message. This error message does not mention outlet, but rather walls – keyword walls is undefined. The definiton of the boundary condition for the walls comes after the outlet definition. One reason for this may be, that OpenFOAM terminates reading the file after the missing semicolon causes a syntax error, and therefore the boundary condition for the walls remain undefined.
This example demonstrates that the error messages are sometimes not very meaningful if they are taken literally. The error was made at the definiton of the BC for the outlet. If only the definition. of the BC of the walls is examined, the cause for the error message will remain unclear, because the BC definition of the walls is perfectly correct.
```
dimensions [0 1 -1 0 0 0 0];
internalField uniform (0 0 0) ;
boundaryField
{
    inlet
    {
        type fixedValue ;
        value uniform (0 0 0.03704) ;
    }
    outlet
    {
        type zeroGradient
    }
    walls
    {
        type fixedValue ;
        value uniform (0 0 0) ;
    } 
}
```
Listing 39: Missing semicolon in the definition of the BC
```
--> FOAM FATAL IO ERROR :
keyword walls is undefined in dictionary "/ home / user / OpenFOAM / user -2.1. x/ run / twoPhaseEulerFoam
    / case /0/ U1 :: boundaryField "
file : / home / user / OpenFOAM / user -2.1. x/ run / twoPhaseEulerFoam / case /0/ U1 :: boundaryField from line
    25 to line 47.
From function dictionary :: subDict ( const word & keyword ) const
in file db / dictionary / dictionary . C at line 461.
FOAM exiting
```
Listing 40: Error message caused by missing semicolon

##### 11.2.4 Switches
Besides key-value pairs there are switches. These enable or disable a function or a feature. Consequently, they only can have a logical value.

Allowed values are: on/off, true/false or yes/no. See Section 57.4.1 for a detailed discussion about valid entries.

##### 11.3 The controlDict
In this dictionary controls regarding time step, simulation time or writing data to hard disk are located. 

The settings in the controlDict are not only read by the solvers but also by all kinds of utilities. E.g. some mesh modification utilities obey the settings of the keywords startFrom and startTime. This has to be kept in mind when using a number of utilities for pre-processing.

##### 11.3.1 Time control
In this Section the most important controls with respect to time step and simulation time are listed. This list makes no claim of completeness.

**startFrom** controls the start time of the simulation. There are three possible options for this keyword.
    **firstTime** the simulation starts from the earliest time step from the set of time directories.
    **startTime** the simulation starts from the time specified by the startTime keyword entry.
    **latestTime** the simulation starts from the latest time step from the set of time directories.
**startTime** start time from which the simulation starts. Only relevant if startFrom startTime has been specified. Otherwise this entry is completely ignored[^19].
**stopAt** controls the end of the simulation. Possible values are {endTime, nextWrite, noWriteNow, writeNow}.
    **endTime** the simulation stops when a specified time is reached.
[^19]If the simulation is set to start from firstTime or latestTime, this keyword can be omitted or the value of this keyword can be anything – startTime banana does not lead to an error, what would be the case if the simulation started from a specific start time.
    **writeNow** the simulation stops after the current time step is completed and the current solution is written to disk.
**endTime** end time for the simulation
**deltaT** time step of the simulation if the simulation uses fixed time steps. In a variable time step simulation this value defines the initial time step.
**adjustTimeStep** controls whether time steps are of fixed or variable length.20 If this keyword is omitted, a fixed time step is assumed by default. When an adjustable time step is used, then the time step length ∆t is controlled via a Courant number criterion. See Section 57.6.4 for more on the Courant number and its influence on the time step.
**runTimeModifiable** controls whether or not OpenFOAM should read certain dictionaries (e.g. controlDict) at the beginning of each time step. If this option is enabled, a simulation can be stopped by using setting stopAt to one of these values {nextWrite, noWriteNow, writeNow}, see Section 12.2.
**maxCo** when the simulation is run with an adjustable time step, then we can specify the maximum Courant number, which is used to impose an upper boundary on the time step size.
**maxDeltaT** when we run a simulation with an adjustable time step, we can provide a manual, hard upper boundary for the maximum time step. This setting limits the time step size, regardless of other conditions allowing for a larger time step, e.g. the Courant number criterion.

In Section 57.6 a couple of aspects regarding time step control are discussed.

##### 11.3.2 Data writing
In controlDict the controls regarding data writing can be found. Often, it is not necessary to save every time step of a simulation. OpenFOAM offers several ways to define how and when the data is to be written to the hard disk. 
**writeControl** controls the timing of writing data to file. Allowed values are {adjustableRunTime, clockTime, cpuTime, runTime, timeStep}. 
    -**runTime** when this option is chosen, then every writeInterval seconds the data is written. This option has no influence on the time step. Hence, the interval at which data is written may/does not exactly match the entry in writeInterval, i.e. for a 1 s interval the data may be written at t = 1.0012, 2.0005, . . . s.
    -**adjustableRunTime** this option allows the solver to adjust the time step, so that every writeInterval seconds the data can be written. This option imposes an upper boundary upon the time step. There must be at least 5 time steps between two instances at which data is written, i.e. ∆t ≤ 0.2 * writeInterval.
    -**timeStep** the data is written every writeInterval time steps. In this case, writeInterval is an integer, not a time.
**writeInterval** a value that controls the interval of data writing. This value gets its meaning from the value assigned to writeControl.
**writeFormat** controls how the data is written to hard disk. It is possible to write text files or binary files. Consequently, the options are {ascii, binary}.
**writePrecision** controls the precision of the values written to the hard disk.
w**riteCompression** controls whether to compress the written files or not. By default compression is disabled. When it is activated, all written files are compressed using gzip.
**timeFormat** controls the format that is used to write the time step folders.
[^20]This keyword is important only for solvers featuring variable time stepping. A fixed time step solver simply ignores this control without displaying any warning or error message.
**timePrecision** specifies the number of digits after the decimal point. The default value is 6.
**purgeWrite** this setting control whether to clear out old time steps. The default value is 0, which means that no clearing out will be conducted. For enabling clearing out old time steps, valid values are positive integer numbers. If enabled with a non-zero value N, only the last N time steps will be retained. Once the simulation has written N time steps to disk, for every new time step saved, the oldest one will be deleted. The initial time step is not affected and will always remain in the case[^21].

**Pitfall: timePrecision**
OpenFOAM is able to automatically increase the value of timePrecision parameter if need arises, e.g. due to a reduction in (dynamic) time step size22. This is typically the case when a simulation diverges and the (dynamic) time step gets decreased by orders of magnitudes. However, simulations that do not diverge may also create the need for an increase in time precision.
```
Increased the timePrecision from 6 to 7 to distinguish between timeNames at time 4.70884
```
Listing 41: Exemplary solver output in the case of an automatic increase of the timePrecision value.

If a simulation that increased its time precision is to be restarted or continued from the latest time step, then the chosen time precision may not be sufficient to represent the present time step values, i.e. a timePrecision of 3 is not sufficient to represent the latest time step at t = 0.1023 s. OpenFOAM will apply rounding to the reach the selected number of digits behind the comma. Consequently, OpenFOAM will fail to find files at time t = 0.102 s.

This behaviour is hard to detect for an unaware user. The only clue for detection lies in this case in the fourth digit behind the comma, which is present in only in the name of the time step directory but not in the timeName that is looked up by OpenFOAM. Listing 42 shows the according error message and a directory listing of the case directory. It is up to the reader to decide whether this is an easy to spot error. The author took some time, which motivated him to elaborate on this issue in this little collection of errors and misbehaviour.
```
--> FOAM FATAL IO ERROR : cannot find file
file : / home / user / OpenFOAM / user -2.3. x/ run / icoFoam / cavity /0.102/ p at line 0.
From function regIOobject :: readStream ()
in file db / regIOobject / regIOobjectRead .C at line 73.
FOAM exiting
user@host :∼/ OpenFOAM / user -2.3. x/ run / icoFoam / cavity$ ls
0 0.1023 constant system
user@host :∼/ OpenFOAM / user -2.3. x/ run / icoFoam / cavity$
```
Listing 42: Exemple of an error caused by an automatic increase of the timePrecision value in the previous simulation run. We fail to restart the simulation as OpenFOAM is not able to find the correct time step.

**Non-pitfall: time step control & writeInterval control of functionObjects**
Note, that the general settings in the file controlDict are not the only settings controlling the time step size. When we use functionObjects to extract data from a running simulation, we can control the interval at which the data from the functionObjects is written independently from the general write interval of the simulation. The functionObjects allow to use the setting adjustableRunTime in the same manner as we can use it for the simulation in general.

[^21]In the file TimeIO.C we see, that each time we reach write-time, the current time step is added to a FIFO stack. Subsequently, the stack’s size is checked against the purgeWrite value. If the stack is larger, then one item will be removed.
[^22]A dynamic increase of the timePrecision value in simulations with fixed time steps indicates a setting in which the time precision is not sufficient to adequately represent the time step. This leads to a automatic increase of time precision after the firsttime step is written to disk. I.e. if ∆t can’t be represented with timePrecision number of digits after the comma, then t1 + ∆t also can’t be represented. Thus, t1 and t1 + ∆t would get the same time name and would consequently be indistinguishable. See Section 57.6.3 on more implementation details on this matter.

Thus in such a case, the time step of the simulation is controlled by the functionObject in addition to the general simulation settings. This can lead to a situation, when the write interval of the functionObject is sufficiently small, that the maximum allowed Courant number is not reached when running the simulation. This is normal behaviour, since there are multiple criteria at work to determine the time step size, and figuratively spoken: the lowest bidder wins.

**Somewhat-non-pitfall: time step control & writeInterval**
The OpenFOAM manual says, that when we select runTime as write-control, then the data is written every writeInterval seconds to disk. This does however, allow for the somewhat strange case of a write-interval which is actually (much) larger than the writeInterval.
Since, we selected runTime as write-control, the writeInterval has no effect on the time step size. If the time step controls allow for a time step larger than writeInterval, e.g. via the Courant criterion, then OpenFOAM will oblige. In this case, after every time step OpenFOAM notices, that the time elapsed since the last write-to-disk is larger than the writeInterval. Thus, it is time to write to disk again.
If we do not want this kind of behaviour, then we need to select adjustableRunTime as our write-control, because then the time step will be checked against the writeInterval. 

**More an observation than a pitfall: time step control & writeInterval**
If we select adjustableRunTime as our write-control, then the time step is adjusted to conform the interval set by writeInterval. It has been observed, that in this case the time step adjustment adheres to the following boundary:
$$
\delta t \
$$
Thus, OpenFOAM performs at least 5 time steps between writing data to disk. This behaviour might be confusing, and it is not explained in the documentation. Also, your trusted author has not been able to infer this behaviour from OpenFOAM’s source code.

##### 11.3.3 Loading additional Libraries
Additional libraries can be loaded with an instruction in controlDict. Listing 43 shows how an external library (in this case a turbulence model that is not included in OpenFOAM) is included. This model can be found at https://github.com/AlbertoPa/dynamicSmagorinsky/.
```
libs ( " libdynamicSmagorinskyModel . so " ) ;
```
Listing 43: Load additional libraries; controlDict entry

Note that the line in Listing 43 is a keyword (libs) followed by a list-type entry. Thus, the space between the keyword and the opening parenthesis is vital, since whitespace is used to separate a keyword from its value.

##### 11.3.4 functions
functions, or functionObjects as they are called in OpenFOAM, offer a wide variety of extra functionality, e.g. probing values or run-time post-processing. See Section 49. 
    ***functions*** can be enabled or disabled at run-time.
	
##### 11.3.5 Outsourcing a dictionary
Some definitions can be outsourced in a seperate dictionary, e.g. the definition of a probe-functionObject. 

**All inclusive**

In this case the probe is defined completely in controlDict.
```
functions
{
    probes1
    {
        type probes ;
        functionObjectLibs (" libsampling . so ") ;
        fields
        ( 
		    p
			U
        );
        outputControl outputTime ;
        outputInterval 0.01;
		
        probeLocations
        (
            (0.5 0.5 0.05)
        );
    } 
}
```
Listing 44: Definition of a probe in controlDict

**Seperate probesDict**
In this case the definition of the probe is done in a seperate file – the probesDict. In controlDict the name of this dictionary is assigned to the keyword dictionary. This dictionary has be located in the system-directory of the case. It is not possible to assign the path of this dictionary to this keyword.
```
functions
{
	probes1
	{
		type probes ;
		functionObjectLibs (" libsampling . so ") ;
		
		dictionary probesDict ;
	} 
}
```
Listing 45: External definition of probes; Entry in controlDict
```
fields
( 
	p
	U
);

outputControl outputTime ;
outputInterval 0.01;

probeLocations
(
	(20.5 0.5 0.05)
);
```
Listing 46: Definition of probes in the file probesDict

**Everything external**
There is also the possibility to move the whole definition of a functionObject into a seperate file. In this case the macro #include is used. This macro is similar to the pre-processor macro if C++.
```
functions
{
	# include " cuttingPlane "
}
```
Listing 47: Completely external definition of a functionObject; Entry in controlDict

```
cuttingPlane
{
	type surfaces ;
	functionObjectLibs (" libsampling . so ") ;
	outputControl outputTime ;
	
	surfaceFormat raw ;
	fields ( alpha1 );
	
	interpolationScheme cellPoint ;
	surfaces
	(
		yNormal
		{
			type cuttingPlane ;
			planeType pointAndNormal ;
			pointAndNormalDict
			{
				basePoint (0 0.1 0) ;
				normalVector (0 1 0) ;
			}
			
			interpolate true ;
		}
	);
}
```
Listing 48: Definition of a cuttingPlane functionObject in a seperate file named cuttingPlane

##### 11.3.6 Pitfalls
***timePrecision***
If the time precision is not sufficient, then OpenFOAM issues a warning message and increases the time precision without aborting a running simulation.

Listing 49 shows such a warning message. The simulation time exceeded 100 s and OpenFOAM figured that the time precision was not sufficient anymore.
```
--> FOAM Warning :
From function Time :: operator ++()
in file db / Time / Time .C at line 1024
Increased the timePrecision from 6 to 13 to distinguish between timeNames at time 100.001
```
Listing 49: Warning message: automatic increase of time precision

A side effect of this increase in time precision was a slight offset in simulation time. The time step of this simulation was 0.001 s and the time steps were written every 0.5 s. As it is clearly visible in Listing 50, the names of the time step folders indicate this offset. This effect on the time step folder names was the reason, the automatic increase of time precision was noticed by the author.

However, automatic increase of time precision has no negative effect on a simulation. This purpose of this section is to explain the cause for this effect.
```
101.5000000002
101.0000000002
100.5000000002
100
99.5
99
98.5
```
Listing 50: Time step folders after increase of time precision

#### 11.4 Run-time modifcations of dictionaries
If the switch runTimeModifiable is set true, on or yes; certain files (e.g. controlDict or fvSolution) are read anew, if a file has changed. In this way, e.g. the write interval can be changed during the simulation. If OpenFOAM detects a run-time modification it issues a message on the Terminal.
```
regIOobject :: readIfModified () :
Re - reading object controlDict from file "/ home / user / OpenFOAM / user -2.1. x/ run /
multiphaseEulerFoam / bubbleColumn / system / controlDict "
```
Listing 51: Detected modifaction of controlDict at run-time of the solver

#### 11.5 The fvSolution dictionary
The file fvSolution contains all settings controlling the solvers and the solution algorithm. This file must contain two dictionaries. The first controls the solvers and the second controls the solution algorithm.

##### 11.5.1 Solver control
The solvers dictionary contains settings that determine the work of the solvers (e.g. solution methods, tolerances, etc.).

##### 11.5.2 Solution algorithm control
The dictionary controlling the solution algorithm is named after the solution algorithm itself. I.e. the name of the dictionary controlling the PIMPLE algorithm is PIMPLE. Note, that the name of this dictionary is in upper case letters unlike most other dictionaries.
Listing 52 shows an example of a PIMPLE dictionary. See Section 42.2 for a detailed discussion on the PIMPLE algorithm.
```
PIMPLE
{
	nOuterCorrectors 1;
	nCorrectors 2;
	nNonOrthogonalCorrectors 0;
	pRefCell 0;
	pRefValue 0;
}
```
Listing 52: The PIMPLE dictionary

#### 11.6 Command line arguments
OpenFOAM’s solvers and utilities can be controlled by a set of command line arguments. Some of them are common to all or many executables, some might be special to a certain tool.

##### 11.6.1 Getting help: -help
The most important command line argument is -help. This is common to all solvers and tools of OpenFOAM and it displays a summary of the respective tool.
##### 11.6.2 Getting in control: -dict
Certain tools expect to find a specific dictionary containing necessary information. With the -dict option, the user can tell the executable, where to look for the dictionary. To the authors knowledge, all tools expecting a dictionary assume a default location and filename. E.g. in older versions of OpenFOAM blockMesh expected to find a dictionary named blockMeshDict in the constant/polyMesh sub-directory of the case’s root, in newer versions it checks also the system directory. If the use chooses to put the dictionary containing into a different folder, he or she can do so, however, the path to the dictionary now needs to be passed using the -dict command line argument.

**no control dict**
The help summary displayed by -help, in some cases, describes the -dict options as follows: read control dictionary from specified location. However, the dictionary specified with the -dict option is not the controlDict. Thus, all entries that go into controlDict need to go into controlDict. For some tools the description of the -dict option seems a little ambiguous. What is meant by control dictionary in this case is the dictionary controlling this specific tool, such as blockMeshDict controlls blockMesh or snappyHexMeshDict controls snappyHexMesh.