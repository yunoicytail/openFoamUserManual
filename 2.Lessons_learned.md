### 2.经验教训
• 对于生产用途，我们强烈建议使用OpenFOAM的正式发布版。随着OpenFOAM开发版本的不断更新，OpenFOAM的行为可能会发生变化。因此，建议用户将其工作完全基于OpenFOAM的正式发布版。这样，一旦您的算例运行起来，它们将可以永远运行，只要您能够在计算机上安装相应版本的OpenFOAM。

• 密切关注OpenFOAM的发展。最新版本可能会提供您急需的某些功能。即使您自己添加了此功能，例如您的自定义求解器或模型，OpenFOAM的开发人员可能会提供该功能的更简洁或更强大的实现。由于很容易在计算机上并行安装多个版本的OpenFOAM，因此请试用最新版本。

• 构建本地安装的源代码文档。如果在HOME主目录中安装了OpenFOAM，它将位于$HOME / OpenFOAM / OpenFOAM-2.3.x / doc / Doxygen中。 这可以使您在离线状态下也可以利用doxygen了解类方法和成员的结构。

• 学习代码。 即使“文档中的代码”听起来根本没有帮助，但只要您能够理解C ++语法，该代码实际上就会告诉您正在发生的事情。熟悉面向对象（OO）软件设计的基本概念。

• 我越是使用OpenFOAM并对其进行修补，我就越确信它的设计确实精巧。但是，得出此结论需要时间和精力。这也可能是一个品味问题。

• 记录自己的工作和尝试过的东西。无需创建数百页，但是好记性不如烂笔头此外，“我曾经尝试过X，然后在Y处写下它”这一事实比“我尝试过X，这就是它的所有细节”更容易被记住。

#### 2.1 哲学
OpenFOAM在很大程度上遵循UNIX哲学的一般规则- 参见埃里克·雷蒙德（Eric S. Raymond）[20]或http://www.catb.org/esr/writings/taoup/html/ch01s06.html – 这应该是出于偶然、设计或必然规律的原因。
1. 模块化规则：编写通过简洁接口连接的简单模块。 当我们查看所有小的前处理和后处理时，我们会看到该规则在起作用。
2. 清晰规则：清晰胜于聪明。    
3. 组成规则：设计与其他程序连接的程序。OpenFOAM广泛使用文本文件可以解释为遵循构成规则的结果。结构化的文本形式可以轻松定义和解释OpenFOAM的输入和输出。
4. 分离规则：策略与机制分离；接口与引擎分开。
5. 简单性规则：设计简洁；仅在必须的地方增加复杂性。  
6. 简约法则：仅在没有其它办法的情况下，才编写大型程序。同样，OpenFOAM是大量专用工具的集合，而不是一个庞大的单程序怪兽（一个大小不适合任何人的程序）。 
7. 透明性规则：可视性设计使得代码检查和调试更加容易。在这里，我们引用Eric S. Raymond所说的：“当您查看软件系统时能够立即了解它在做什么以及如何工作时，它就是透明的。” CFD被认为非常复杂，但是，OpenFOAM的高级代码的近似数学表示法可以看作是OpenFOAM遵守透明规则的一个示例。  
8. 鲁棒性规则：鲁棒性是透明性和简单性的产物。   
9. 表示法则：将知识整合到数据中，因此程序逻辑可以是愚蠢且健壮的。尽管在陈述该规则时没有考虑到面向对象的问题，但我们可以观察到，OpenFOAM的数据结构和类吸收了很多复杂性。因此，顶级求解器源代码看起来并不引人注目。
10. 最不惊奇的规则：在界面设计中，总是要做最不惊奇的事情。当我们查看所有共享的命令行选项时，我们会看到该规则在起作用。所有支持时间选择的工具都提供通用选项，例如lastTime或noZero。
11. 静默规则：当程序无话可说时，它什么也不需要说。大多数功能对象都遵守该规则，这些功能对象为用户提供了取消在终端输出的选择。这些输出在测试期间可能有用。 但是，一旦算例正确设置之后，功能对象就将其输出写入到文件夹postProcessing中的相应文件就足够了。  
12. 修复规则：当程序必须退出时，请尽早提示并尝试退出。您是否注意到了FOAM FATAL ERROR消息？
13. 经济规则：程序员的时间很昂贵；优先于机器时间节省时间。如果我们允许自己对此规则有一个非常广泛的了解，我们可以假设，OpenFOAM的为关键字2指定默认值的机制就是从用户角度遵循该规则的一个示例，即用户的时间得到了保留。
14. 生成规则：避免hand-hacking（如何翻译比较好？）；尽自己的最大可能编写程序。我们可以看到大量使用
模板作为遵循生成规则的OpenFOAM的示例。TurbulenceModels框架3是建模框架的一个示例，该框架被编码一次并应用于多种不同的形式。但是，这仅在更广泛的意义上适用，因为声明该规则时并未考虑C++的模板。
15. 优化规则：优化前的原型。在优化之前先使它工作。
16. 多元化原则：不信任所有主张“唯一真实解决方案”的主张。 OpenFOAM为用户提供了很多选择，例如要使用的求解器，求解算法以及离散化和插值方案。
17. 可扩展性规则：为未来而设计，因为它比您想象的要来得更早。OpenFOAM有时会根据其版本或输入文件的格式表现出不同的行为。有关fixedValue边界条件的输入语法差异的示例，请参见第36.4.1节。在这种情况下，重要的教训是允许在不破坏兼容性的情况下进行代码的演变。

#### 2.2 通过使用学习
• 数字错误也可能会毁掉你的CFD，并非每次模拟的崩溃都是OpenFOAM中的错误引起的，CFD中的数字也很容易引起崩溃。  

• 切勿禁用OpenFOAM的单元检查。供参考：可以在OpenFOAM安装的etc目录中的全局controlDict中完成。 

• 许多类提供可选的调试信息。调试标志可以通过全局controlDict以及算例的controlDict进行控制。 

• 尽情玩吧！学习的很大一部分是反复试验。尽管我们中的许多人都将自己视为科学家或渴望成为科学家，但请不要忽略简单的尝试和错误的价值。

#### 2.3 Learning by tinkering with OpenFOAM
##### 2.3.1 I learned something today.
• Have a look at the test directory in the applications folder of your installation, e.g. in $HOME/OpenFOAM/OpenFOAM-2.3.x/applications/test. There, you find examples of how to use certain data structures, which may be exactly what you need when implementing something.    
• Create your own test application, if you are about to implement something new. With a test application, you can keep the problem nearly primitive, thus, allowing yourself more mental freedom to explore and to learn. Later, you might be more likely to implement your solver / library with less bugs and errors.    
• OpenFOAM makes heavy use of C++’s language features and other smart moves in OO software design. Thus, make sure you understand the basics of the following concepts / language features before you try to study / modify the code of OpenFOAM. Your life gets easier if you do. inheritance virtually everything of OpenFOAM is described and implemented using the concept of classes. Classes can be derived from other classes to implement an is a relationship, i.e. every cat is an animal
but not vice versa. Note: C++ support multiple inheritance, i.e. a class can be derived from a number of classes, not just
one. Other programming languages are (slightly) different in this aspect, e.g. Java allows you to derive only from one class, however, you can implement interfaces. poly-morphism is a wider concept, however it applies also to inheritance and classes.
templates allow the user to write code for as-of-yet unspecified data types. Container classes are the prime example for the use of templates (or generics as this concept is called in Java). Examples of the excellent use of the aforementioned concepts is the turbulence modelling framework discussed in Section 32.1.2, or the Lagrangian modelling framework discussed in Section 40.2.    
##### 2.3.2 Trouble with the code?    
it does not compile    
• Due to the heavy use of templates the syntax and the compiler error messages are quite lengthy and often hard to read. However, the compiler error message might contain exactly the information you need to track down the error, e.g. a data-type mismatch. Familiarize yourself with C++’s syntax if you haven’t already.    
If you are baffled by the very lengthy error messages, take special care to the top and the bottom of the error message, as it is there where you might find the most useful clues. it does not run    
• Spurious crashes (e.g. caused by floating point errors) may be an indication of class members being un-initialized.    
• No offence, but it’s most probably your fault.    