### 2.经验教训
* 对于生产用途，我们强烈建议使用OpenFOAM的正式发布版。随着OpenFOAM开发版本的不断更新，OpenFOAM的行为可能会发生变化。因此，建议用户将其工作完全基于OpenFOAM的正式发布版。这样，一旦您的算例运行起来，它们将可以永远运行，只要您能够在计算机上安装相应版本的OpenFOAM。
* 密切关注OpenFOAM的发展。最新版本可能会提供您急需的某些功能。即使您自己添加了此功能，例如您的自定义求解器或模型，OpenFOAM的开发人员可能会提供该功能的更简洁或更强大的实现。由于很容易在计算机上并行安装多个版本的OpenFOAM，因此请试用最新版本。
* 构建本地安装的源代码文档。如果在HOME主目录中安装了OpenFOAM，它将位于$HOME / OpenFOAM / OpenFOAM-2.3.x / doc / Doxygen中。 这可以使您在离线状态下也可以利用doxygen了解类方法和成员的结构。
* 学习代码。 即使“文档中的代码”听起来根本没有帮助，但只要您能够理解C ++语法，该代码实际上就会告诉您正在发生的事情。熟悉面向对象（OO）软件设计的基本概念。
* 我越是使用OpenFOAM并对其进行修补，我就越确信它的设计确实精巧。但是，得出此结论需要时间和精力。这也可能是一个品味问题。
* 记录自己的工作和尝试过的东西。无需创建数百页，但是好记性不如烂笔头此外，“我曾经尝试过X，然后在Y处写下它”这一事实比“我尝试过X，这就是它的所有细节”更容易被记住。

#### 2.1 哲学
OpenFOAM在很大程度上遵循UNIX哲学的一般规则- 参见埃里克·雷蒙德（Eric S. Raymond）[20]或http://www.catb.org/esr/writings/taoup/html/ch01s06.html – 这应该是出于偶然、设计或必然规律的原因。
1. 模块化规则：编写通过简洁接口连接的简单模块。 当我们查看所有小的前处理和后处理时，我们会看到该规则在起作用。
2. 清晰规则：清晰胜于聪明。    
3. 组成规则：设计与其他程序连接的程序。OpenFOAM广泛使用文本文件可以解释为遵循构成规则的结果。结构化的文本形式可以轻松定义和解释OpenFOAM的输入和输出。
4. 分离规则：策略与机制分离；接口与引擎分开。
5. 简单性规则：设计简洁；仅在必须的地方增加复杂性。  
6. 简约法则：仅在没有其它办法的情况下，才编写大型程序。同样，OpenFOAM是大量专用工具的集合，而不是一个庞大的单程序怪兽（一个大小不适合任何人的程序）。 
7. 透明性规则：可视性设计使得代码检查和调试更加容易。在这里，我们引用Eric S. Raymond所说的：“当您查看软件系统时能够立即了解它在做什么以及如何工作时，它就是透明的。” CFD被认为非常复杂，但是，OpenFOAM的高级代码的近似数学表示法可以看作是OpenFOAM遵守透明规则的一个示例。  
8. 鲁棒性规则：鲁棒性是透明性和简单性的产物。   
9. 表示法则：将知识整合到数据中，因此程序逻辑可以是愚蠢且健壮的。尽管在陈述该规则时没有考虑到面向对象的问题，但我们可以观察到，OpenFOAM的数据结构和类吸收了很多复杂性。因此，顶级求解器源代码看起来并不引人注目。
10. 最不惊奇的规则：在界面设计中，总是要做最不惊奇的事情。当我们查看所有共享的命令行选项时，我们会看到该规则在起作用。所有支持时间选择的工具都提供通用选项，例如lastTime或noZero。
11. 静默规则：当程序无话可说时，它什么也不需要说。大多数功能对象都遵守该规则，这些功能对象为用户提供了取消在终端输出的选择。这些输出在测试期间可能有用。 但是，一旦算例正确设置之后，功能对象就将其输出写入到文件夹postProcessing中的相应文件就足够了。  
12. 修复规则：当程序必须退出时，请尽早提示并尝试退出。您是否注意到了FOAM FATAL ERROR消息？
13. 经济规则：程序员的时间很昂贵；优先于机器时间节省时间。如果我们允许自己对此规则有一个非常广泛的了解，我们可以假设，OpenFOAM的为关键字2指定默认值的机制就是从用户角度遵循该规则的一个示例，即用户的时间得到了保留。
14. 生成规则：避免hand-hacking（如何翻译比较好？）；尽自己的最大可能编写程序。我们可以看到大量使用
模板作为遵循生成规则的OpenFOAM的示例。TurbulenceModels框架3是建模框架的一个示例，该框架被编码一次并应用于多种不同的形式。但是，这仅在更广泛的意义上适用，因为声明该规则时并未考虑C++的模板。
15. 优化规则：优化前的原型。在优化之前先使它工作。
16. 多元化原则：不信任所有主张“唯一真实解决方案”的主张。 OpenFOAM为用户提供了很多选择，例如要使用的求解器，求解算法以及离散化和插值方案。
17. 可扩展性规则：为未来而设计，因为它比您想象的要来得更早。OpenFOAM有时会根据其版本或输入文件的格式表现出不同的行为。有关fixedValue边界条件的输入语法差异的示例，请参见第36.4.1节。在这种情况下，重要的教训是允许在不破坏兼容性的情况下进行代码的演变。

#### 2.2 通过使用学习
* 数字错误也可能会毁掉你的CFD，并非每次模拟的崩溃都是OpenFOAM中的错误引起的，CFD中的数字也很容易引起崩溃。  
* 切勿禁用OpenFOAM的单元检查。供参考：可以在OpenFOAM安装的etc目录中的全局controlDict中完成。 
* 许多类提供可选的调试信息。调试标志可以通过全局controlDict以及算例的controlDict进行控制。 
* 尽情玩吧！学习的很大一部分是反复试验。尽管我们中的许多人都将自己视为科学家或渴望成为科学家，但请不要忽略简单的尝试和错误的价值。

#### 2.3 通过修补OpenFOAM进行学习
##### 2.3.1 我今天学到了一些东西
* 查看您安装的Applications文件夹中的test目录，如$HOME/OpenFOAM/OpenFOAM-2.3.x/applications/test，在这里，您可以找到有关如何使用某些数据结构的示例，这些数据结构可能正是您实现某些功能时所需的。
* 如果您要实施新的功能，请创建自己的test应用程序。借助新的test程序，您可以使待解决的问题保持原始状态，从而使自己有更多的自由来进行探索和学习。此后，您可以用更少的错误和bugs来实现您的求解器/库。
* OpenFOAM在面向对象的软件设计中大量使用C++的语言功能和其他举措。因此，在尝试学习/修改OpenFOAM的代码之前，请确保您了解以下概念/语言功能的基础。这样您的学习会变得更加轻松。
1. 继承：实际上，OpenFOAM的所有内容都是使用类的概念来描述和实现的。 可以从其他类派生类来实现关系，即，每只猫都是动物，但反之则不是。

*注意：C ++支持多种继承，即一个类可以从许多类中派生而不仅仅是一个类。 在这方面，其他编程语言（略）有所不同，例如 Java只允许您从一个类派生，但是，您可以实现接口。*

2. 多态是一个更广泛的概念，但是它也适用于继承和类。

3. 模板允许用户为尚未指定的数据类型编写代码。 容器类是使用模板（或在Java中称为泛型）的主要示例。

*第32.1.2节中讨论的湍流建模框架或第40.2节中讨论的拉格朗日建模框架很好地示范了上述的概念。*
##### 2.3.2 代码有问题吗？ 
***它不能编译***
* 由于大量使用模板，因此语法和编译器错误消息非常冗长，并且通常很难阅读。 但是，编译器错误消息可能恰好包含跟踪错误所需的信息，例如 数据类型不匹配。 如果您还不熟悉C ++的语法，请先熟悉一下。
* 如果您对冗长的错误消息感到困惑，请特别注意错误消息的顶部和底部，因为在该位置可能会找到最有用的线索。 

***它没有运行***
* 虚假崩溃（例如，由浮点错误引起的崩溃）可能表明类成员未初始化。
* 没有恶意，但这很可能是您的错。