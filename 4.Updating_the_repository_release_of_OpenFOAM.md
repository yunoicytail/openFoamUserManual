### 4 更新OpenFOAM仓库版本
#### 4.1 版本管理
OpenFOAM is distributed in two different ways. There is the repository release that can be downloaded using the Git repository. The version number of the repository release is marked by the appended x, e.g. OpenFOAM 2.1.x. This release is updated regularly and is in some ways a development release. Changes and updates are released quickly, however, there is a larger possibility of bugs in this release. Because this release is updated frequently an OpenFOAM installation of version 2.1.x on one system may or will be different to another installation of version 2.1.x on an other system. Therefore, each installation has an additional information to mark different builds of OpenFOAM. The version number is accompanied by a hash code to uniquely identify the various builds of the repository release, see Listing 9. Whenever OpenFOAM is updated and compiled anew, this hash code gets changed. Two OpenFOAM installations are on an equal level, if the build is equal.
OpenFOAM以两种不同的方式分发。 有一个可以使用Git存储库下载的存储库版本。 储存库版本的版本号由附加的x标记，例如 OpenFOAM2.1.x。 该版本会定期更新，并在某种程度上是开发版本。 更改和更新很快发布，但是，此版本中出现错误的可能性更大。 由于此发行版经常更新，因此在一个系统上的版本2.1.x的OpenFOAM安装可能与在另一系统上的版本2.1.x的另一安装不同。 因此，每个安装都有附加的信息来标记不同版本的OpenFOAM。 版本号随附一个哈希码，以唯一地标识存储库版本的各个内部版本，请参见清单9。每当更新并重新编译OpenFOAM时，此哈希码都会更改。 如果内部版本相同，则两个OpenFOAM安装处于相同级别。
```
Build : 2.1. x -9 d344f6ac6af
```
Listing 9: 仓库版本的完整版本标识

Apart from the repository release there are also pack releases. These are upadated periodically in longer intervals than the repository release. The version number of a pack release contains no x, e.g. OpenFOAM 2.1.1. In contrast to the repository release all installations of the same version number are equal. Due to the longer release cycle the pack release is regarded to be less prone to software bugs.
除了版本库之外，还有软件包版本。 与存储库版本相比，这些更新的间隔时间更长。 软件包发行版的版本号不包含x，例如 OpenFOAM 2.1.1。 与版本库相反，所有相同版本号的安装都是相同的。 由于发行周期较长，因此认为发行包不太容易出现软件错误。

There are several types of those releases. The are precompiled packages for widely used Linux distributions (Ubuntu, SuSE and Fedora) and also a source pack. The source pack can be installed on any system on which the source codes compile (usually all kinds of Linux running computers, e.g. high performance computing clusters, or even computers running other operation systems, e.g. 

这些版本有几种类型。 这些是针对广泛使用的Linux发行版（Ubuntu，SuSE和Fedora）的预编译软件包，也是一个源码包。 可以将源代码包安装在可编译源代码的任何系统上（通常是运行Linux的各种计算机，例如高性能计算集群，甚至运行其他操作系统的计算机）。例如[Mac OSX](http://openfoamwiki.net/index.php/Howto_install_OpenFOAM_v21_Mac)甚至是[Windows](http://openfoamwiki.net/index.php/Tip_Cross_Compiling_OpenFOAM_in_Linux_For_Windows_with_MinGW)).

#### 4.2 检查更新
If OpenFOAM was installed from the repository release, updating is rather simple. To update OpenFOAM simply use Git to check if there are newer source files available. Change in the Terminal to the root directory of the OpenFOAM installation and execute git pull.
如果从存储库版本安装了OpenFOAM，则更新非常简单。 要更新OpenFOAM，只需使用Git来检查是否有更新的源文件。 在终端中切换到OpenFOAM安装的根目录，然后执行git pull。

If there are newer files in the repository Git will download them and display a summary of the changed files.
如果存储库中有较新的文件，Git将下载它们并显示已更改文件的摘要。

```
user@host :∼$ cd $FOAM_INST_DIR
user@host :∼/ OpenFOAM$ cd OpenFOAM -2.1. x
user@host :∼/ OpenFOAM / OpenFOAM -2.1. x$ git pull
remote : Counting objects : 67 , done .
remote : Compressing objects : 100% (13/13) , done .
remote : Total 44 ( delta 32) , reused 43 ( delta 31)
Unpacking objects : 100% (44/44) , done .
From git :// github . com / OpenFOAM / OpenFOAM -2.1. x
72 f00f7 ..21 ed37f master -> origin / master
Updating 72 f00f7 ..21 ed37f
Fast - forward
.../ extrude / extrudeToRegionMesh / createShellMesh .C | 10 +-
.../ extrude / extrudeToRegionMesh / createShellMesh .H | 7 +-
.../ extrudeToRegionMesh / extrudeToRegionMesh .C | 157 ++++++++ - - - - -
.../ Templates / KinematicCloud / KinematicCloud .H | 6 +-
.../ Templates / KinematicCloud / KinematicCloudI .H | 7 +
.../ baseClasses / kinematicCloud / kinematicCloud . H | 47 ++++++ -
6 files changed , 193 insertions (+) , 41 deletions ( -)
```
Listing 10: 有可用的更新

If OpenFOAM is up to date, then Git will output a corresponding message.
如果OpenFOAM是最新的，则Git将输出相应的消息：

```
user@host :∼/ OpenFOAM / OpenFOAM -2.1. x$ git pull
Already up -to - date .
```
Listing 11: OpenFOAM是最新的

#### 4.3 仅检查更新
If you want to check for updates only, without actually making an update, Git can be invoked using a special option (see Listings 12 and 13). In this case Git only checks the repository and displays its findings without actually making any changes. The option responsible for this is --dry-run. Notice, that git fetch is called instead of git pull. *git pull calls git fetch to download the remote files and then calls git merge to merge the retrieved files with the local files. So checking for updates is actually done by git fetch.* 
如果您只想检查更新而没有实际进行更新，则可以使用特殊选项来调用Git（请参见清单12和13）。 在这种情况下，Git仅检查存储库并显示其发现结果，而无需实际进行任何更改。 负责此操作的选项是--dry-run。 注意，调用了git fetch而不是git pull。 *git pull调用git fetch下载远程文件，然后调用git merge将检索到的文件与本地文件合并。 因此，检查更新实际上是通过git fetch完成的。*

```
user@host :∼$ cd OpenFOAM / OpenFOAM -2.0. x/
user@host :∼/ OpenFOAM / OpenFOAM -2.0. x$ git fetch --dry - run -v
remote : Counting objects : 189 , done .
remote : Compressing objects : 100% (57/57) , done .
remote : Total 120 ( delta 89) , reused 93 ( delta 62)
Receiving objects : 100% (120/120) , 17.05 KiB , done .
Resolving deltas : 100% (89/89) , completed with 56 local objects .
From git :// github . com / OpenFOAM / OpenFOAM -2.0. x
5 ae2802 ..97 cf67d master -> origin / master
user@host :∼/ OpenFOAM / OpenFOAM -2.0. x$
```
Listing 12: 仅检查更新–可用更新
```
user@host :∼$ cd OpenFOAM / OpenFOAM -2.1. x/
user@host :∼/ OpenFOAM / OpenFOAM -2.1. x$ git fetch --dry - run -v
From git :// github . com / OpenFOAM / OpenFOAM -2.1. x
= [ up to date ] master -> origin / master
user@host :∼/ OpenFOAM / OpenFOAM -2.1. x$
```
Listing 13: 仅检查更新–最新

#### 4.4 安装更新
After updates have been downloaded by git pull the changed source files need to be compiled in order to update the executables. This is done the same way as is it done when installing OpenFOAM. Simply call ./Allwmake to compile. This script recognises changes, so unchanged files will not be compiled again. So, compiling after an update takes less time than compiling when installing OpenFOAM.
在通过git pull下载更新后，需要编译更改的源文件才能更新可执行文件。 这与安装OpenFOAM时所执行的方法相同。 只需调用./Allwmake进行编译。 该脚本可以识别更改，因此不会再次编译未更改的文件。 因此，更新后进行编译所需的时间少于安装OpenFOAM时所需的时间。
##### 4.4.1 工作流程
Listing 14 shows the necessary commands to update an existing OpenFOAM installation. However this applies only for repository releases (e.g. OpenFOAM-2.1.x). The point releases (every version of OpenFOAM without an x in the version number) are not updated in the same sense as the repository releases. For simplicity an update of a point release (OpenFOAM-2.1.0 → OpenFOAM-2.1.1) can be treated like a complete new installation, see Section 3.6.
清单14显示了更新现有OpenFOAM安装所需的命令。 但这仅适用于存储库版本（例如OpenFOAM-2.1.x）。 点版本（OpenFOAM的每个版本，版本号中没有x）的更新方式与存储库版本的更新方式不同。 为简单起见，可以将Point Release（OpenFOAM-2.1.0→OpenFOAM-2.1.1）的更新视为全新安装，请参见第3.6节。

The first two commands in Listing 14 change to the directory of the OpenFOAM installation. Then the latest source files are downloaded by invoking git pull.
清单14中的前两个命令更改为OpenFOAM安装目录。 然后，通过调用git pull下载最新的源文件。

The statement in red can be omitted. However if the compilation ends with some errors, this command usually does the trick, see Section 4.5.2. The last statement causes the source files to be compiled. If wclean all was not called before, then only the files that did change are compiled. If wclean all was invoked then everything is compiled. This may or will take much longer.
红色的语句可以省略。 但是，如果编译以某些错误结束，则此命令通常可以解决问题，请参见第4.5.2节。 最后一条语句导致源文件被编译。 如果以前未调用wclean all，则仅编译发生更改的文件。 如果调用了wclean all，则将编译所有内容。 这可能或将花费更长的时间。

If there is enough time for the update (e.g. overnight), then wclean all should be called before compiling. This will in most cases make sure that compilation of the updated sources succeeds.
如果有足够的时间进行更新（例如整夜），则应在编译之前调用wclean all。 在大多数情况下，这将确保更新源的编译成功。

```
cd $FOAM_INST_DIR
cd OpenFOAM -2.1. x
git pull
wclean all
./ Allwmake
```
Listing 14: 更新现有的OpenFOAM安装的完整的工作流程

##### 4.4.2 问题排查
If compilation reports some errors it is helpful to call ./Allwmake again. This reduces the output of the successful operations considerably and the actual error messages of the compiler are easier to find.
如果编译报告一些错误，则再次调用./Allwmake会很有帮助。 这大大减少了成功操作的输出，并且更容易找到编译器的实际错误消息。

#### 4.5 更新问题
##### 4.5.1 缺少安装包
If there has been an upgrade of the operating system it can happen, that some relevant packages have been removed in the course of the update (e.g. if these packages are only needed to compile OpenFOAM and the OS ’thinks’ that these packages aren’t in use). Consequently, if recompiling OpenFOAM fails after an OS upgrade, missing packages can be the cause.
如果对操作系统进行了升级，则可能会发生，这意味着在更新过程中已删除了一些相关的软件包（例如，如果仅需要这些软件包来编译OpenFOAM，并且操作系统“认为”这些软件包不是必需的） 正在使用）。 因此，如果在操作系统升级后重新编译OpenFOAM失败，则可能是缺少软件包的原因。

##### 4.5.2 库的更新
When libraries have been updated, they have to be recompiled. Otherwise solvers would call functions that are not (yet) implemented. In order to avoid this problem the corresponding library has to be recompiled.
库更新后，必须重新编译它们。 否则，求解器将调用尚未（尚未实现）的函数。 为了避免此问题，必须重新编译相应的库。

```
wclean all
```
Listing 15: 使用wclean准备重新编译

The brute force variant would be, to recompile OpenFOAM as a whole, instead of recompiling a updated library.
暴力变体将是重新编译整个OpenFOAM，而不是重新编译更新的库。

##### 4.5.3 更新的源无法编译
In some cases, e.g. when there were changes in the organisation of the source files, the sources fail to compile right away. Or, if there is any other reason the sources won’t compile and the cause is not found, then a complete recompilation of OpenFOAM may be the solution of choice. Although compiling OpenFOAM takes its time, this may take less time than tracking down all errors.
在某些情况下，例如 当源文件的组织发生变化时，源文件将无法立即编译。 或者，如果有其他原因导致无法编译源代码且未找到原因，则可以选择完全重新编译OpenFOAM。 尽管编译OpenFOAM需要花费时间，但与跟踪所有错误相比，这可能花费更少的时间。

To recompile OpenFOAM the sources need to be reset. Instead of deleting OpenFOAM and installing it again, there is a simple command that takes care of this.
要重新编译OpenFOAM，需要重置源。 有一个简单的命令可以解决此问题，而不是删除OpenFOAM并重新安装。

```
git clean - dfx
```
Listing 16: 使用git重置源

The command listed in Listing 16 causes git to erase all files git does not track. That means all files that are not part of the git-repository are deleted. In this case, this is the official git-repository of OpenFOAM. git clean removes all files that are not under version control recursively starting from the current directory. The option -d means that also untracked folders are removed.
清单16中列出的命令使git擦除git没有跟踪的所有文件。 这意味着所有不属于git-repository的文件都将被删除。 在这种情况下，这是OpenFOAM的官方git存储库。 git clean从当前目录开始递归删除所有不受版本控制的文件。 选项-d表示还删除了未跟踪的文件夹。

After the command from Listing 16 is executed, the sources have to be compiled as described in Section 3.3.
执行清单16中的命令后，必须按照3.3节中的说明编译源。

##### 4.5.4 自有代码无法运行
Updating your repository release of OpenFOAM leads to interesting effects. When libraries of OpenFOAM are updated, their implementation might change. Even if the updated code is fully compatible with the previous one, the compiled libaries might look different after the update. Thus, even if the update maintains code compatibility, the update might break binary compatibility. Thus, a recompilation of your own code following the update of the underlying OpenFOAM installation is required.
更新您的OpenFOAM的存储库版本会产生有趣的效果。 更新OpenFOAM的库时，它们的实现可能会更改。 即使更新的代码与先前的代码完全兼容，更新后的编译库看起来也可能不同。 因此，即使更新保持代码兼容性，更新也可能破坏二进制兼容性。 因此，需要在基础OpenFOAM安装更新之后重新编译您自己的代码。

Lost binary compatibility after an update of OpenFOAM leads to segmentation faults when loading a library with lost binary compatibility. This happens because our own solvers dynamically load the required libraries of OpenFOAM at start-up and the memory layout of certain objects of the library has changed since the update.
更新OpenFOAM之后丢失的二进制兼容性会导致在加载丢失的二进制兼容性的库时导致分段错误。 发生这种情况是因为我们自己的求解器在启动时会动态加载所需的OpenFOAM库，并且自更新以来该库某些对象的内存布局已更改。

有关此主题的更多信息，请参见以下资源：
* https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C%2B%2B
* https://en.wikipedia.org/wiki/Binary_code_compatibility
* https://en.wikipedia.org/wiki/Source_code_compatibility

Losing binary compatibility happens not after every update, and it also does not happen to every library. Thus, you may encounter such problems long after the update, and after you successfully used other solvers and libraries of your creation. Thus, the source of the issues described in this Section may not be immediately clear to the user. Thus, if your code suddenly fails to run properly for no good reason, recomile and see what happens.
失去二进制兼容性不会在每次更新后发生，并且并非在每个库中都发生。 因此，在更新之后以及成功使用其他创建的求解器和库之后，您可能会遇到此类问题。 因此，用户可能无法立即清楚了解本节中描述的问题的根源。 因此，如果您的代码突然由于没有充分原因而无法正常运行，请重新编译并查看会发生什么。