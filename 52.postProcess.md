### 52 postProcess随着OpenFOAM-4.0重写了功能对象框架。在这个重写过程中,引入了一个postProcess（后处理）实用工具，并在大多数求解器[154]中添加了postProcess选项。postProcess取代了某些后处理实用工具，例如sample。#### 52.1 用法##### 52.1.1 预配置函数对象有许多预先配置好的函数对象，可以与后处理一起使用。这些可在**$FOAM_ETC/caseDicts/postProcessing**中找到。也可以使用**postProcess**的**-list**选项列出它们。```user@host:∼$ postProcess -list  ```列表346：**postProcess**的**-list**选项命令##### 52.1.2 Passing 参数列表347显示了如何确定速度场的最小值和最大值。```user@host:∼$ postProcess -fields ’(U.water)’ -func "minMaxMagnitude(U.water)"  ```​				列表347：确定速度场的极值​		列表348展示了如何同时处理两个速度场，我们只需逗号分隔列表。```user@host:∼$postProcess -fields ’(U.air U.water)’ -func "minMaxMagnitude(U.air,U.water)"   ```​					列表348：确定两个速度场的极值​		在列表349中，我们处理一个单独的速度场，并将附加参数传递给函数对象。在这种情况下，我们不想知道最大最小速度的位置。```user@host:∼$postProcess -fields ’(U.air)’ -func "minMaxMagnitude(U.air,location=off) ```​				列表349：确定没有定位的速度场的极值​		运行函数对象之后，我们看到数据被写入后处理目录。我们注意到文件夹名对应于通过**-func**选项传递的参数。```user@host :∼$ ls postProcessingminMaxMagnitude(U.air, location =off) minMaxMagnitude(U.air,U.water)  ```​		列表350：运行上面的两个函数对象**postProcessing**目录的内容##### 52.1.3 后处理分解案例我们可以像并行运行求解器一样，并行运行postProcess。这允许我们去后期处理一个还没有重建的算例。```mpirun -np 4 postProcess -parallel  ```​		列表351：并行运行*postProcess*，即对分解后的算例进行后处理