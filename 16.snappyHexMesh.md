### 16 snappyHexMesh
snappyHexMesh，也称为snappy，是一种网格化工具，能够对任意三角形表面周围的空间进行网格化，例如 STL表面网格。通常在外部空气动力学中这种情况比较多。snappyHexMesh只能与blockMesh结合使用，因为它需要背景网格。

#### 16.1 相关资料
不幸的是，snappyHexMesh的复杂性超出了官方文档的内容。官方文档（用户指南）可在本地OpenFOAM安装的doc/Guides-a4或doc/Guides-usletter中找到，也可以在http://www.openfoam.org/docs/user/ 在线找到。您可以在$FOAM_UTILITIES/mesh/generation/snappyHexMesh找到注释的snappyHexMeshDict。对于所有由特定的字典文件控制的程序（例如decomposePar，topoSet等），都是这种情况。
在某些情况下，snappy的个别功能在发布这些功能的发行说明中进行了讨论。相关的比较好的文档的另一个来源是在OpenFOAM研讨会上的演示。在互联网上搜索适当的关键字可以找到这些文档。
与任何其他工具一样，鼓励大家运行OpenFOAM提供的教程并进行练习。教程案例还为构建您自己的案例提供了良好的起点。

#### 16.2 工作流程
snappyHexMesh创建网格的过程分两步：
1. 首先利用blockMesh创建背景网格。这对于snappy的后续工作绝对必要，建议背景网格由纵横比为1的全六角形单元（即立方体形单元）组成。此外，背景网格的单元格边缘与三角形表面相交越多越好。
2. 然后snappyHexMesh执行三个基本步骤：
（a）Castellating
通过拆分和移除三角形表面外的像元来近似三角形表面。单元拆分可以细化对象表面附近的背景网格单元。单元移除可以移除对象内部的背景网格单元。
（b）单元捕捉
单元捕捉修改剩余的背景网格，以重建对象的表面。
（c）附加层
附加层将附加的六面体单元引入对象的边界表面，以确保良好的网格质量。

#### 16.3 示例：浴缸
在实际示例的帮助下，我们现在将讨论snappyHexMesh的一些功能，因为问题和见解通常是在实际使用中出现的。我们示例中的浴缸具有比较复杂的形状，因此我们不愿通过手工或通过脚本来痛苦地创建blockMeshDict。对于这种复杂的几何图形，可以使用复杂的网格划分工具（例如snappy）。
![figure17](images/15.PNG)
图17：一个浴缸，排水管的最底部的出口补丁标记为灰色。

##### 16.3.1 边界层
Boundary layers are added in the last stage of snappy’s operation. These are added on a per-patch basis. Thus, it is not possible to add layers only to parts of a patch. On the patch itself, we can control the regions in which to add a layer by the keyword featureAngle. The operation of the layer addition stage is controlled by the addLayersControls dictionary of snappyHexMeshDict.
Some of the entries of the addLayersControls dictionary are self-explanatory, such as the layers dictionary specifying the patches on which to add layers of cells. However, other parameters are not that obvious in their meaning.
**featureAngle**
The featureAngle is the angle between two consecutive faces. This parameter controls the behaviour of the
layer addition stage at corners and bends.
![figure18](images/16.PNG)
Figure 18: A badly chosen featureAngle causes snappy to add incomplete boundary layers.

**slipFeatureAngle**
At the outlet patch of our domain, the layer added to the wall patch meets the outlet patch, i.e. vertices need to be added to the outlet patch in order to properly grow a layer of cells onto the wall patch. See the left side of Figure 19. In order to achieve this, we must be able to alter the outlet patch during layer addition even though, we do not add a layer to the outlet patch itself.
This feature is discussed in the release notes47 of OpenFOAM-2.2.0.
![figure19](images/17.PNG)
![figure19](images/18.PNG)
Figure 19: The boundary layers added by snappy. On the left, layer addition went as we intended it to do; on the right, we see the effect of the (missing) keyword slipFeatureAngle of the addLayersControls dictionary of snappyHexMeshDict.

**Exclude patches**
We have to freedom to tell snappyHexMesh to leave patches alone. Thus, during layer addition these patches remain untouched. This allows us to reverse the effect we achieved with the slipFeatureAngle parameter. By specifically exluding the outlet from any layer addition activity (see Listing 134), we end up with a collapsing cell layer at the boundary of the outlet patch, see Figure 20.
```
layers
{
bathTub
{
nSurfaceLayers 2;
}
outlet
{
nSurfaceLayers 0;
} }
```
Listing 134: The layers sub-dictionary of the addLayersControl dictionary: specifically excluding a patch from layer addition.

This example of use may most probably not meet practical requirements, however, it demonstrates how snappy works. The take-away message might be that nSurfaceLayers beats slipFeatureAngle.
A non-academic (read less-useless) theoretical use-case for excluding patches from layer addition might be, when we later merge different meshes. In that case, we might want to preserve some patches for the merging operation.
![figure20](images/19.PNG)
Figure 20: A collapsing boundary layer. Maybe we did not want the mesh that way, however, we told snappy to create it exactly that way.

##### 16.3.2 Pitfalls, sources of error and hints on malfunction
**Run time**
If snappyHexMesh is finished in less than a second, then something is wrong. As snappyHexMesh performs up to three work intensive steps (castellation, snapping and layer addition), a run of snappyHexMesh takes a couple of seconds or even longer (tens of seconds).
**Units**
When creating a mesh with snappyHexMesh different scales (meter vs. millimeter) of the background mesh and the STL-mesh are a frequent source of error. Check the following things:
1. The unit of the vertex coordinates in blockMeshDict
2. The value of the convertToMeters keyword in blockMeshDict
3. The unit in which the STL was created