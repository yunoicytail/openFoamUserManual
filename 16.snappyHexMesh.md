### 16 snappyHexMesh
snappyHexMesh, also referred to as snappy, is a meshing tool that is able to mesh the space around an arbitrary triangulated surface, e.g. an STL surface-mesh. This is generally the case in external aerodynamics. snappyHexMesh can only be used in conjunction with blockMesh, since it requires a background mesh.

#### 16.1 Documentation
Unfortunately, the complexity of snappyHexMesh outweighs the available on-board documentation. The onboard documentation (User Guide) can be found in doc/Guides-a4 or doc/Guides-usletter of your local OpenFOAM installation or online at http://www.openfoam.org/docs/user/. You find a commented snappyHexMeshDict at $FOAM_UTILITIES/mesh/generation/snappyHexMesh. This is the case for all utilities which are controlled by an utility-specific dictionary file, such as decomposePar, topoSet and many more.
Individual features of snappy are in some cases discussed in the release notes of the release with which these features were rolled out. Another source of good documentation of snappy are presentations held at the OpenFOAM Workshops. An internet search with appropriate keywords will point the reader to them, since some of them are publicly available on the internets.
As with any other tool, the reader is encouraged to run the tutorials provided by OpenFOAM and play around with them. The tutorial cases also provide a good starting base for building your own cases.

#### 16.2 Work flow
The creation of a mesh by snappyHexMesh is following a two step approach:
1. The background mesh is created by blockMesh. This is absolutely necessary to the later work of snappy. It is advised for the background mesh to consist of all-hex cells with an aspect ratio of 1, i.e. cube-shaped cells. It is furthermore beneficial to have many intersections of the background mesh’s cell-edges with the tri-surface.
2. snappyHexMesh then perfoms three basic steps:
(a) Castellating
The tri-surface is approximated by splitting and removing cells outside the tri-surface. Cell splitting The cells of the background mesh near the objects surface are refined. Cell removal Cells of the background mesh inside the object are removed.
(b) Snapping
Cell snapping The remaining background mesh is modified in order to reconstruct the surface of the object.
(c) Layer addition
Layer addition Additional hexahedral cells are introduced on the boundary surface of the object to ensure a good mesh quality.

#### 16.3 Example: Bath Tub
With the help of an actual example, we will now discuss some of snappyHexMesh’s features, as problems and insights most often come with pratical use. Our bath tub has a non-trivial shape, thus we are not inclined to painfully create the blockMeshDict by hand or by script. For complicated geometries a sophisticated meshing tool such as snappy is the way to go.
![figure17](images/15.PNG)
Figure 17: A bath tub. The outlet patch is marked grey at the very bottom of the drain tube.

##### 16.3.1 Boundary layers
Boundary layers are added in the last stage of snappy’s operation. These are added on a per-patch basis. Thus, it is not possible to add layers only to parts of a patch. On the patch itself, we can control the regions in which to add a layer by the keyword featureAngle. The operation of the layer addition stage is controlled by the addLayersControls dictionary of snappyHexMeshDict.
Some of the entries of the addLayersControls dictionary are self-explanatory, such as the layers dictionary specifying the patches on which to add layers of cells. However, other parameters are not that obvious in their meaning.
**featureAngle**
The featureAngle is the angle between two consecutive faces. This parameter controls the behaviour of the
layer addition stage at corners and bends.
![figure18](images/16.PNG)
Figure 18: A badly chosen featureAngle causes snappy to add incomplete boundary layers.

**slipFeatureAngle**
At the outlet patch of our domain, the layer added to the wall patch meets the outlet patch, i.e. vertices need to be added to the outlet patch in order to properly grow a layer of cells onto the wall patch. See the left side of Figure 19. In order to achieve this, we must be able to alter the outlet patch during layer addition even though, we do not add a layer to the outlet patch itself.
This feature is discussed in the release notes47 of OpenFOAM-2.2.0.
![figure19](images/17.PNG)
![figure19](images/18.PNG)
Figure 19: The boundary layers added by snappy. On the left, layer addition went as we intended it to do; on the right, we see the effect of the (missing) keyword slipFeatureAngle of the addLayersControls dictionary of snappyHexMeshDict.

**Exclude patches**
We have to freedom to tell snappyHexMesh to leave patches alone. Thus, during layer addition these patches remain untouched. This allows us to reverse the effect we achieved with the slipFeatureAngle parameter. By specifically exluding the outlet from any layer addition activity (see Listing 134), we end up with a collapsing cell layer at the boundary of the outlet patch, see Figure 20.
```
layers
{
bathTub
{
nSurfaceLayers 2;
}
outlet
{
nSurfaceLayers 0;
} }
```
Listing 134: The layers sub-dictionary of the addLayersControl dictionary: specifically excluding a patch from layer addition.

This example of use may most probably not meet practical requirements, however, it demonstrates how snappy works. The take-away message might be that nSurfaceLayers beats slipFeatureAngle.
A non-academic (read less-useless) theoretical use-case for excluding patches from layer addition might be, when we later merge different meshes. In that case, we might want to preserve some patches for the merging operation.
![figure20](images/19.PNG)
Figure 20: A collapsing boundary layer. Maybe we did not want the mesh that way, however, we told snappy to create it exactly that way.

##### 16.3.2 Pitfalls, sources of error and hints on malfunction
**Run time**
If snappyHexMesh is finished in less than a second, then something is wrong. As snappyHexMesh performs up to three work intensive steps (castellation, snapping and layer addition), a run of snappyHexMesh takes a couple of seconds or even longer (tens of seconds).
**Units**
When creating a mesh with snappyHexMesh different scales (meter vs. millimeter) of the background mesh and the STL-mesh are a frequent source of error. Check the following things:
1. The unit of the vertex coordinates in blockMeshDict
2. The value of the convertToMeters keyword in blockMeshDict
3. The unit in which the STL was created