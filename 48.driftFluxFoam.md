### 48 driftFluxFoam
driftFluxFoam是OpenFOAM的一个求解器，用于模拟分散粒子在液体中的沉降。driftFluxFoam是在settlingFoam的基础上发展起来的，随着OpenFOAM-2.3.1138的发布，settlingFoam已经停止了使用。  
Brennan[12]在他的论文中使用了settlingFoam，其中包含了从欧拉双流体模型方程推导漂移通量模型的大量信息。driftFluxFoam的头文件将此求解器描述如下：  
* 可求解2个不可压缩流体的混合方法和相对运动相的近似漂移通量。  
* 可用于模拟分散相的沉降和其它类似的分离问题。  
*FloftFluxFoam*与OpenFOAM的通用求解器的设计是兼容的，因此该求解器可以使用所有可用的湍流模型。它还可以使用MRF方法和fvOptions框架。  

#### 48.1 控制方程
混合物的控制方程由双流体模型导出[12，31]。  

##### 48.1.1 混合连续方程
通过将两相的连续性方程相加，可以很容易地导出混合连续性方程：  
$$
(129)
$$
再结合本构关系  
$$
(130)
(131)
$$
我们可以得到  
$$
(132)
$$
##### 48.1.2 混合动量方程
**基于文献推导**
混合动量方程的推导类似于混合连续性方程的推导。因此，我们跳过一般的推导，让感兴趣的读者参考适当的文献[12，31]。在本节中，我们将重点介绍在driftFluxFoam中实现的特定方程的推导。  
我们从布伦南[12]附录中给出的推导开始：  
$$
(133)
$$
我们特别注意到扩散应力******Pαkρkukmukm******，它表示由于相之间的相对运动而产生的动量扩散。
$$
(134)
$$
为了方便起见，我们引入符号τdm表示扩散应力  
$$
τdm = Xαkρkukmukm (135)
$$
用ukm表示k相相对于混合物质心的速度；ukm也称为k相的扩散速度  
$$
ukm = uk − um (136)
$$
Ishii和Hibiki[31]指出了两相扩散速度之间的关系：
$$
α1ρ1u1m + α2ρ2u2m = 0 (137)
$$
因此，我们可以从扩散应力τdm中消除u1m  
$$
τdm = α1ρ1 α2ρ2 α1ρ1 2 u22m + α2ρ2u22m (138)
τdm = α2ρ2u22m α2ρ2 α1ρ1
+ 1
(139)
τdm = α2ρ2u22m α2ρ2 + α1ρ1 α1ρ1 
(140)
τdm = α2ρ2u22m  ρm α1ρ1 
(141)
τdm = ρm α2 α1 ρ2 ρ1 u22m (142)
$$
**实现**
从清单310中的源代码中，我们可以看到扩散应力和动量方程LHS上的第四项。  
```
 fvVectorMatrix UEqn
 ( 3 fvm :: ddt ( rho , U)
 + fvm :: div ( rhoPhi , U)
 + MRF . DDt ( rho , U)
 + fvc :: div ( UdmModel . tauDm () )
 + turbulence -> divDevRhoReff (U)
 ==
 fvOptions ( rho , U)
 );
```
清单310:driftFluxFoam的动量方程

接下来，我们来看看扩散应力的实现。  
```
 tmp < volSymmTensorField > Foam :: relativeVelocityModel :: tauDm () const
 { 
	  volScalarField betac ( alphac_ * rhoc_ ) ;
	  volScalarField betad ( alphad_ * rhod_ ) ;
 // Calculate the relative velocity of the continuous phase w.r.t the mean
 volVectorField Ucm ( betad * Udm_ / betac );
 return tmp < volSymmTensorField >
 (
 new volSymmTensorField
 (
 " tauDm ",
 betad * sqr ( Udm_ ) + betac * sqr ( Ucm )
 )
 );
 }
```
清单311:relativeVelocityModel计算的driftFluxFoam的扩散应力

现在，我们将源代码转化为数学公式：
$$
τbm = βdu2
dm + βcu2
cm (143)
$$
和
$$
βd = αdρd (144)
βc = αcρc (145)
ucm = βd βc udm (146)
$$
我们得到  
$$
τbm = βdu2
dm + βc βd βc 2 u2
dm (147)
τbm = βdu2
dm 
1 +
βd βc 
(148)
τbm = αdρdu2
dm 
1 +
αdρd αcρc 
(149)
τbm = αdρdu2
dm αcρc + αdρd αcρc 
(150)
τbm = αdρdu2
dm
ρm αcρc
(151)
τbm = ρm αd αc ρdρc u2
dm (152)
$$
我们注意到，从源码中获得的公式（152），与从文献中获得的公式（142）一样，第二相是分散相d。

**相对速度**
扩散速度udm和漂移速度udj通过本构关系连接：
$$
udm = ρ1 ρm udj (153)
$$
我们在清单316和317中的源代码中也发现了这种关系。Ishii和Hibiki[31]指出，在分散两相流的情况下，阻力相关性应该用漂移速度udj表示。  
相对速度模型提供了一种返回UDM的方法，但是，在清单316和317的源代码中，我们发现公式（153）被翻译成C++。在这里，udm的表达式由密度比和漂移速度的关系式组成，后者将单个粒子的最终速度与分散相的体积分数联系起来。  

#### 48.2 不可压缩两相干涉混合
不可压缩两相相互作用混合物是driftFluxFoam的输运模型，该类将保存两相的所有信息，并提供混合物的数量，floftfluxfoam求解混合物的动量和压力方程。因此，该求解器处于单相求解器和全双流体求解器（如twoPhaseEulerFoam）之间。  
通过此传输模型，混合量传播到湍流模型，因为湍流模型在构建时接收传输模型类作为模板参数，这是一个新的模板湍流建模框架的多功能性的例子。而之前的settlingFoam具有硬编码k− 湍流模型，粘度模型也是硬编码的。

#### 48.3 混合物粘度模型
沉降设备中固体浓度不同时，固体颗粒的存在会影响流体性质。因此除了使用混合物密度外，还必须使用混合粘度。  

##### 48.3.1 混合粘度模型
mixtureViscosityModel类是实际粘度模型的抽象基类。此类的用途与$FOAMïSRC/transportModels/incompressible/viscosityModels/viscosityModel中单相粘度模型viscosityModel的基类类似。这两个基类非常相似，它们的实现只有细微的差别。  

##### 48.3.2 泥浆
泥浆混合粘度模型是参考托马斯[60]对牛顿粘度的修正。  
$$
(154)
$$
计算混合粘度的源代码是将上述数学公式直接转化为C++。  

```
 Foam :: tmp < Foam :: volScalarField >
 Foam :: mixtureViscosityModels :: slurry :: mu ( const volScalarField & muc ) const
 { 
	  return
 ( 
	  muc *(1.0 + 2.5* alpha_ + 10.05* sqr ( alpha_ ) + 0.00273* exp (16.6* alpha_ ))
 );
 }
```
清单312：通过泥浆混合粘度模型计算混合物粘度  

##### 48.3.3 塑性粘度
塑性粘度模型是基于表现出塑性行为的液体的通用粘度模型发展而来的（155）。  
$$
τ = aCb α (155)
$$
在driftFluxFoam中实现的塑性模型可转换为：  
$$
µ = min [µc + k ∗ (10n α − 1), µmax] (156)
$$
清单313显示了计算混合粘度的源代码。第二项中的-1确保在分散体积分数消失的情况下，我们保持连续相的层流粘度，因为任何数的幂为0时等于1。  
```
Foam :: tmp < Foam :: volScalarField >
 Foam :: mixtureViscosityModels :: plastic :: mu ( const volScalarField & muc ) const
 { 
	  return min
 ( 
	  muc
 + plasticViscosityCoeff_
 *(
 pow
 (
 scalar (10) ,
 plasticViscosityExponent_ * alpha_
 ) - scalar (1)
 ) ,
 muMax_
 );
 }
```
清单313：用塑性混合粘度模型计算混合粘度。

##### 48.3.4 Bingham塑性粘度
BinghamPlastic是宾汉塑性粘度模型。

#### 48.4 相对速度模型-受阻沉降
在本节中，我们使用符号v表示速度，以遵循Brennan[12]的表示法以及OpenFOAM的源代码。  

##### 48.4.1 基类
基类保存派生模型的公共数据。基类保存扩散速度Udm的私有字段Udm_u，并声明一个抽象方法correct（）。派生类使用correct（）方法来计算扩散速度Udm。  
基类的方法Udm（）简单地返回Udm，方法tauDm（）返回由扩散速度计算出的扩散应力。  

**扩散速度**
相对速度模型的类包含扩散速度的向量场。内部场值是根据实际使用的模型确定的，但是边界条件是从混合速度场中获取的。  
因此我们可以从基类的源代码进行读取。在清单314中，我们看到了负责扩散速度的初始值设定项。  

```
 Udm_
 ( 
	  IOobject
 ( 
	 " Udm ", 6 alphac_ . time () . timeName () ,
 alphac_ . mesh () ,
 IOobject :: NO_READ ,
 IOobject :: AUTO_WRITE
 ) ,
 alphac_ . mesh () ,
 dimensionedVector (" Udm", dimVelocity , vector :: zero ) ,
 mixture .U () . boundaryField () . types ()
 )
```
清单314:relativeVelocityModel类的构造函数中Udm的初始值设定项。

为了解释清单314，我们需要找出GeometricField139类的相应构造函数。在清单315中，我们看到构造函数接收五个参数，其中最后一个参数有一个默认值。如果我们只传递四个参数，那么第五个参数将由默认值确定。  

```
 // - Constructor given IOobject , mesh , dimensioned <Type > and patch types . 
  GeometricField
 ( 
	  const IOobject &,
 const Mesh &,
 const dimensioned < Type >& ,
 const wordList & wantedPatchTypes ,
 const wordList & actualPatchTypes = wordList ()
 );
```
清单315：清单314中代码调用的构造函数。

如果我们比较清单314和清单315的构造函数调用的参数，我们会发现传递的第一个参数显然是一个IOobject，第二个参数是对mesh本身的引用，从清单314中对alphac_.mesh（）的调用中可以明显看出这一点。  
第三个参数确定字段的类型以及初始值。模板参数类型确定字段是标量字段、向量字段还是张量字段。当清单314中传递一个dimensionedVector时，类型的计算结果为vector 140。  
第四个参数是边界类型的列表，因为我们只传递了一维值作为第三个参数，所以到目前为止还没有传递关于场的边界条件的信息。通过传递混合速度场的边界类型列表（mixture.U（）），场Udm_的边界条件就可以被指定了。  
由于清单314中没有传递第五个参数，因此使用了call wordList（）的返回值。  

##### 48.4.2 simple模型
名为simple的模型类似于Brennan[12]使用的模型，归因于Dahl[17]。该模型与Vesilind[65]模型（158）非常相似，Brennan[12]解释了基数从Euler数e到基数10的变化，可以更接近Dahl[17]收集的实验数据。  
$$
vs = v0 10−kα (157)
$$
The implementation of the simple model is more or less a direct translation from math (157) to C++. In the exponent the maximum of the dispersed volume fraction and zero is taken to avoid numerical trouble from negative values of the volume fraction. Reversing the sign in an exponent is never a good idea in numerical simulation.
simple模型的实现或多或少是直接从公式（157）到C++的转换。在指数中取离散体积分数的最大值和零，避免了体积分数负值带来的数值麻烦。在数值模拟中，反转指数的符号从来不是一个好主意。
```
 void Foam :: relativeVelocityModels :: simple :: correct ()
 { 
	  Udm_ = ( rhoc_ / rho () )* V0_ * pow ( scalar (10) , -a_ * max ( alphad_ , scalar (0) )) ;
 }
```
清单316：通过simple模型相对速度计算弥散扩散速度Udm

##### 48.4.3 general模型
被称为general的模型很可能是基于Takács的模型[59]，头文件中没有引用任何文献。Takács[59]模型（159）是基于Vesilind[65]模型的所谓双指数模型，见（158）[28，12]。
$$
vs = v0 e−nX (158)
vs = v0 
$$
其中
vs沉降速度
v0最大沉降速度
n模型参数
rh 阻碍沉降的rh沉降参数
rp 低固相浓度下的rp沉降参数
X悬浮固体浓度
$$
(160)
$$
实现如下：
```
 void Foam :: relativeVelocityModels :: general :: correct ()
 { 
	  Udm_ =
 ( rhoc_ / rho () )
 * V0_
 *(
 exp (- a_ * max ( alphad_ - residualAlpha_ , scalar (0) ))
 - exp (- a1_ * max ( alphad_ - residualAlpha_ , scalar (0) ))
 );
 }
```
清单317：用general相对速度模型计算弥散扩散速度Udm。  

#### 48.5 settlingFoam
在这里，我们将更仔细地了解settlingFoam（OpenFOAM-2.2.x的版本），它是floftfluxfoam的前身。通过比较这两个求解器的实现，我们可以观察到OpenFOAM源代码库向更封装的方法的转变。  

##### 48.5.1 混合粘度
settlingFoam仅限于塑性或Bingham粘度模型。清单318显示了settlingFoam的代码，它计算混合物的粘度。此代码位于源文件中，源文件包含在求解器的PIMPLE循环体中。  
因此，对于该求解器，没有封装对混合物粘度的处理。粘度模型没有放在单独的文件中，求解器本身的代码中就包含了粘度模型的所有内容。用一个或多个混合粘度模型扩展求解器需要在correctVisity.H文件中构建扩展的if级联。  
```
 { 
	  /* compute plastic viscosity */
 mul = muc +
 plasticViscosity
 ( 
	  /* code removed for brevity */
 );
 if ( BinghamPlastic )
 {
 volScalarField tauy = yieldStress
 (
 /* see yieldStress .H */
 );
 mul =
 /* compute contribution of yield stress */
 + mul ;
 }

 mul = min ( mul , muMax ) ;
 }
```
清单318:OpenFOAM-2.2.x的settingfoam文件correctVisity.H中对混合物粘度的计算。

##### 48.5.2 相对速度模型
在撰写本文时，OpenFOAM-2.2.x的settlingFoam提供了与driftFluxFoam相同的相对速度模型选择。然而，在实现方面，我们注意到，模型选择同样是在if语句级联中完成的。  
```
 if ( VdjModel == " general ") 
  { 
	   Vdj = V0 *
 ( 
	  exp (-a * max ( alpha - alphaMin , scalar (0) ))
 - exp (- a1 * max ( alpha - alphaMin , scalar (0) ))
 );
  } 
   else if ( VdjModel == " simple ")
 {
 Vdj = V0 * pow (10.0 , -a * alpha );
 }
 else
 {
 FatalErrorIn ( args . executable () )
 << " Unknown VdjModel : " << VdjModel
 << abort ( FatalError ) ;
 }

 Vdj . correctBoundaryConditions () ;
```
清单319:OpenFOAM-2.2.x的文件calcVdj.H中settlingFoam的相对速度计算。

##### 48.5.3 湍流
settlingFoam中的湍流同twoPhaseEulerFoam采用相似的方式实现。两个求解器根据当时的需要都具有硬编码的k− 湍流模型。