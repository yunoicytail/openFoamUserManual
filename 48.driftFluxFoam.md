### 48 driftFluxFoam
*driftFluxFoam* is a solver of OpenFOAM to simulate e.g. settling of disperse particles in a liquid. driftFluxFoam is the successor of settlingFoam, which has been discontinued with the release of OpenFOAM-2.3.1138.
*driftFluxFoam*是OpenFOAM的一个求解器，用于模拟分散粒子在液体中的沉降。driftFluxFoam是在settlingFoam的基础上发展起来的，随着OpenFOAM-2.3.1138的发布，settlingFoam已经停止了使用。

*settlingFoam* was used by Brennan [12] in his thesis, which contains a lot of information on deriving the drift flux model from the Eulerian two-fluid model equations. The header of driftFluxFoam describes this solver as follows:
*Brennan[12]在他的论文中使用了settlingFoam，其中包含了从欧拉双流体模型方程推导漂移通量模型的大量信息。driftFluxFoam的头文件将此求解器描述如下：
	Solver for 2 incompressible fluids using the mixture approach with the drift-flux approximation for relative motion of the phases.
	Used for simulating the settling of the dispersed phase and other similar separation problems.
	求解2个不可压缩流体的混合方法和相对运动相的漂移通量近似。
	用于模拟分散相的沉降和其它类似的分离问题。
*driftFluxFoam* complys with the generic solver design of OpenFOAM, thus this solver can use all available turbulence models. It also can use the MRF method and the fvOptions framework.
*FloftFluxFoam*与OpenFOAM的通用解算器设计兼容，因此该解算器可以使用所有可用的湍流模型。它还可以使用MRF方法和fvOptions框架。

#### 48.1 Governing equations 控制方程
The governing equations for the mixture are derived from the two-fluid model [12, 31].
合物的控制方程由双流体模型导出[12，31]。

##### 48.1.1 Mixture continuity equation 混合连续方程
The mixture continuity equation can be easily derived by adding the continuity equations of the two phases:
通过将两相的连续性方程相加，可以很容易地导出混合连续性方程：
(129)
with the constitutive relations
再结合本构关系
(130)
(131)
we gain
我们可以得到
(132)
##### 48.1.2 Mixture momentum equation 混合动量方程
**Derivation from literature**
基于文献推导
The derivation of the mixture momentum equation is analogous to the derivation of the mixture continuity equation. Therefore, we skip the general derivation and refer the interested reader to the appropriate literature [12, 31]. In this section, we want to focus on the derivation of the specific equations implemented in driftFluxFoam.
We start from the derivation given in the appendix of Brennan [12]:

混合动量方程的推导类似于混合连续性方程的推导。因此，我们跳过一般的推导，让感兴趣的读者参考适当的文献[12，31]。在本节中，我们将重点介绍在driftFluxFoam中实现的特定方程的推导。

我们从布伦南[12]附录中给出的推导开始：

(133)
we pay special attention to the diffusion stress ********Pαkρkukmukm********, which represents momentum diffusion due to the relative motion between the phases.
我们特别注意扩散应力******Pαkρkukmukm******，它表示由于相之间的相对运动而产生的动量扩散。
(134)
For convenience we introduce the symbol τdm for the diffusion stress
为了方便起见，我们引入符号τdm表示扩散应力
τdm = Xαkρkukmukm (135)
with ukm, the velocity of the phase k relative to the mixture’s centre of mass; ukm is also referred to as diffusion velocity of the phase k 
用ukm表示k相相对于混合物质心的速度；ukm也称为k相的扩散速度
ukm = uk − um (136)
Ishii and Hibiki [31] states a relation between the diffusion velocities of the two phases:
Ishii和Hibiki[31]指出了两相扩散速度之间的关系：
α1ρ1u1m + α2ρ2u2m = 0 (137)
Thus, we can eliminate u1m from the diffusion stress τdm
因此，我们可以从扩散应力τdm中消除u1m
τdm = α1ρ1 α2ρ2 α1ρ1 2 u22m + α2ρ2u22m (138)
τdm = α2ρ2u22m α2ρ2 α1ρ1
+ 1
(139)
τdm = α2ρ2u22m α2ρ2 + α1ρ1 α1ρ1 
(140)
τdm = α2ρ2u22m  ρm α1ρ1 
(141)
τdm = ρm α2 α1 ρ2 ρ1 u22m (142)
**实现**
From the source code in Listing 310 we see the diffusion stress an the fourth term on the LHS of the momentum equation.
从清单310中的源代码中，我们可以看到扩散应力和动量方程LHS上的第四项。
```
 fvVectorMatrix UEqn
 ( 3 fvm :: ddt ( rho , U)
 + fvm :: div ( rhoPhi , U)
 + MRF . DDt ( rho , U)
 + fvc :: div ( UdmModel . tauDm () )
 + turbulence -> divDevRhoReff (U)
 ==
 fvOptions ( rho , U)
 );
```
Listing 310: The momentum equation of driftFluxFoam
清单310:driftFluxFoam的动量方程

Next, we take a look at the implementation of the diffusion stress.
接下来，我们来看看扩散应力的实现。
```
 tmp < volSymmTensorField > Foam :: relativeVelocityModel :: tauDm () const
 { 
	  volScalarField betac ( alphac_ * rhoc_ ) ;
	  volScalarField betad ( alphad_ * rhod_ ) ;
 // Calculate the relative velocity of the continuous phase w.r.t the mean
 volVectorField Ucm ( betad * Udm_ / betac );
 return tmp < volSymmTensorField >
 (
 new volSymmTensorField
 (
 " tauDm ",
 betad * sqr ( Udm_ ) + betac * sqr ( Ucm )
 )
 );
 }
```
Listing 311: The diffusion stress of driftFluxFoam computed by the relativeVelocityModel
清单311:relativeVelocityModel计算的漂流泡沫的扩散应力

And now, we translate the source code into some math:
现在，我们将源代码转化为数学：
τbm = βdu2
dm + βcu2
cm (143)
with和
βd = αdρd (144)
βc = αcρc (145)
ucm = βd βc udm (146)
we gain 我们得到
τbm = βdu2
dm + βc βd βc 2 u2
dm (147)
τbm = βdu2
dm 
1 +
βd βc 
(148)
τbm = αdρdu2
dm 
1 +
αdρd αcρc 
(149)
τbm = αdρdu2
dm αcρc + αdρd αcρc 
(150)
τbm = αdρdu2
dm
ρm αcρc
(151)
τbm = ρm αd αc ρdρc u2
dm (152)
We notice, that (152) derived from the source code, equals (142), derived from literature  with phase 2 being the disperse phase d.
我们注意到，（152）来自源代码，等于（142），来自文献，第2相是分散相d。

**Relative velocity 相对速度**
The diffusion velocity udm and the drift velocity udj are linked by a constitutive relation:
扩散速度udm和漂移速度udj通过本构关系连接：

udm = ρ1 ρm udj (153)
We find this relation also in the source code in Listings 316 and 317. Ishii and Hibiki [31] state, that in the case of dispersed two-phase flow the drag correlation should be expressed in terms of the drift velocity udj .
The relative velocity models provide a method that returns udm, however, in the source code of the Listings 316 and 317 we find relation (153) translated into C++. There, the expression for udm consists of the density ratio and a relation for the drift velocity, which links the terminal velocity of a single particle and the volume fraction of the disperse phase.
我们在清单316和317中的源代码中也发现了这种关系。Ishii和Hibiki[31]指出，在分散两相流的情况下，阻力相关性应该用漂移速度udj表示。

相对速度模型提供了一种返回UDM的方法，但是，在清单316和317的源代码中，我们发现关系（153）被翻译成C++。在这里，udm的表达式由密度比和漂移速度的关系式组成，后者将单个粒子的最终速度与分散相的体积分数联系起来。

#### 48.2 incompressibleTwoPhaseInteractingMixture 不可压缩两相干涉混合
The class incompressibleTwoPhaseInteractingMixture serves as the transport model for driftFluxFoam. This class holds all the information of the two phases and provides the mixture quantities. driftFluxFoam solves the momentum and pressure equations for the mixture. Thus, this solver is in between a single-phase solver and a full two-fluid solver such as twoPhaseEulerFoam.  
不可压缩两相相互作用混合物是漂流泡沫的输运模型。该类保存两相的所有信息，并提供混合物的数量。floftfluxfoam求解混合物的动量和压力方程。因此，该解算器位于单相解算器和全双流体解算器（如twoPhaseEulerFoam）之间。

Via this transport model, the mixture quantities propagate to the turbulence model, since the turbulence model receives a transport model class as template parameter at construction. This is one example for the versatility of the new, templated turbulence modelling framework. The precursor settlingFoam had a hardcoded k −  turbulence model. Also the viscosity model was kind of hard-coded.
通过此传输模型，混合量传播到湍流模型，因为湍流模型在构建时接收传输模型类作为模板参数。这是一个新的模板湍流建模框架的多功能性的例子。前驱体沉降泡沫具有硬编码k− 湍流模型。粘度模型也是硬编码的。

#### 48.3 Mixture viscosity models 混合物粘度模型
Settling equippment is often operated with solids concentrations at which the presence of the solid particles affect fluid properties. Besides using the mixture density, a mixture viscosity also has to be used.
沉降设备通常在固体浓度下运行，在此浓度下固体颗粒的存在会影响流体性质。除了使用混合物密度，还必须使用混合物粘度。

##### 48.3.1 mixtureViscosityModel 混合粘度模型
The class mixtureViscosityModel is the abstract base class for the actual viscosity models. This class serves a similar purpose as the base class for the single-phase viscosity models viscosityModel located in $FOAM_SRC/transportModels/incompressible/viscosityModels/viscosityModel. These two base classes are rather similar and there are only slight differences in their implementations.

类mixtureViscosityModel是实际粘度模型的抽象基类。此类的用途与$FOAMïSRC/transportModels/incompressible/viscosityModels/viscosityModel中单相粘度模型viscosityModel的基类类似。这两个基类非常相似，它们的实现只有细微的差别。

##### 48.3.2 slurry 泥浆
The slurry mixture viscosity model is a correction for the Newtonian viscosity with reference to Thomas [60].
泥浆混合物粘度模型是参考托马斯[60]对牛顿粘度的修正。

(154)
The source code computing the mixture viscosity is a direct translation of the math above into C++.
计算混合粘度的源代码是将上述数学直接转化为C++。

```
 Foam :: tmp < Foam :: volScalarField >
 Foam :: mixtureViscosityModels :: slurry :: mu ( const volScalarField & muc ) const
 { 
	  return
 ( 
	  muc *(1.0 + 2.5* alpha_ + 10.05* sqr ( alpha_ ) + 0.00273* exp (16.6* alpha_ ))
 );
 }
```
Listing 312: The calculation of the mixture viscosity by the slurry mixture viscosity model
清单312：通过泥浆混合物粘度模型计算混合物粘度

##### 48.3.3 plastic
The plastic viscosity model is based on a generic viscosity model (155) for liquids exhibiting plastic behaviour.
塑性粘度模型基于表现出塑性行为的液体的通用粘度模型（155）。

τ = aCb α (155)
The plastic model implemented in driftFluxFoam translates to:
在driftFluxFoam中实现的塑料模型可转换为：

µ = min [µc + k ∗ (10n α − 1), µmax] (156)
Listing 313 shows the source code computing the mixture viscosity. The -1 in the second term ensures, that we retain the laminar viscosity of the continuous phase in the case the dispersed volume fraction vanishes, since anything to the power of zero equals one.
清单313显示了计算混合物粘度的源代码。第二项中的-1确保在分散体积分数消失的情况下，我们保持连续相的层流粘度，因为任何0的幂等于1。


```
Foam :: tmp < Foam :: volScalarField >
 Foam :: mixtureViscosityModels :: plastic :: mu ( const volScalarField & muc ) const
 { 
	  return min
 ( 
	  muc
 + plasticViscosityCoeff_
 *(
 pow
 (
 scalar (10) ,
 plasticViscosityExponent_ * alpha_
 ) - scalar (1)
 ) ,
 muMax_
 );
 }
```
Listing 313: The calculation of the mixture viscosity by the plastic mixture viscosity model.
清单313：用塑料混合物粘度模型计算混合物粘度。

##### 48.3.4 BinghamPlastic
BinghamPlastic is a Bingham plastic model.
宾汉塑料是宾汉塑料模型。

#### 48.4 Relative velocity models - hindered settling 相对速度模型-受阻沉降
In this section we use the symbol v for the velocity to follow the notation of Brennan [12] as well as the source code of OpenFOAM.
在本节中，我们使用符号v表示速度，以遵循Brennan[12]的表示法以及OpenFOAM的源代码。

##### 48.4.1 The base class 基类
The base class holds the data common to the derived models. The base class holds the private field Udm_ for the diffusion velocity udm and declares an abstract method correct(). The method correct() is used by the derived classes to compute the diffusion velocity Udm_.
基类保存派生模型的公共数据。基类保存扩散速度Udm的私有字段Udm_u，并声明一个抽象方法correct（）。派生类使用correct（）方法来计算扩散速度Udm。

The method Udm() of the base class simply returns Udm_, and the method tauDm() returns the diffusion stress computed from the diffusion velocity.
基类的方法Udm（）简单地返回Udm，方法tauDm（）返回由扩散速度计算出的扩散应力。

**The diffusion velocity 扩散速度**
The class for the relative velocity model holds a vector field for the diffusion velocity. The internal field values are determined from the actual model in use, however, the boundary conditions are taken over from the mixture velocity field.
This, we can read from the source code of the base class. In Listing 314 we see the initializer responsible for the diffusion velocity.
相对速度模型的类包含扩散速度的向量场。内部场值是根据实际使用的模型确定的，但是边界条件是从混合速度场中获取的。

这，我们可以从基类的源代码中读取。在清单314中，我们看到了负责扩散速度的初始值设定项。

```
 Udm_
 ( 
	  IOobject
 ( 
	 " Udm ", 6 alphac_ . time () . timeName () ,
 alphac_ . mesh () ,
 IOobject :: NO_READ ,
 IOobject :: AUTO_WRITE
 ) ,
 alphac_ . mesh () ,
 dimensionedVector (" Udm", dimVelocity , vector :: zero ) ,
 mixture .U () . boundaryField () . types ()
 )
```
Listing 314: The initializer entry for Udm_ in the constructor of the relativeVelocityModel class.
清单314:relativeVelocityModel类的构造函数中Udm\的初始值设定项。

For the interpretation of Listing 314 we need to dig out the appropriate constructor of the class GeometricField139. In Listing 315 we see that the constructor receives five arguments, of which the last has a default value. If we pass only four arguments, the fifth will be determined from the default value.
为了解释清单314，我们需要找出GeometricField139类的相应构造函数。在清单315中，我们看到构造函数接收五个参数，其中最后一个参数有一个默认值。如果我们只传递四个参数，那么第五个参数将由默认值确定。

```
 // - Constructor given IOobject , mesh , dimensioned <Type > and patch types . 
  GeometricField
 ( 
	  const IOobject &,
 const Mesh &,
 const dimensioned < Type >& ,
 const wordList & wantedPatchTypes ,
 const wordList & actualPatchTypes = wordList ()
 );
```
Listing 315: The signature of the constructor called by the code in Listing 314.
清单315：清单314中代码调用的构造函数的签名。

If we compare the arguments of the constructor call of Listing 314 and the signature in Listing 315, we see that the first argument passed is clearly an IOobject. The second argument is a reference to the mesh itself, which is obvious from the call to alphac_.mesh() in Listing 314.
如果我们比较清单314的构造函数调用的参数和清单315中的签名，我们会发现传递的第一个参数显然是一个IOobject。第二个参数是对mesh本身的引用，从清单314中对alphac\.mesh（）的调用中可以明显看出这一点。

The third argument determines the type of the field as well as the initial value. The template parameter Type determines whether the field is a scalar, a vector or a tensor field. As a dimensionedVector is passed in Listing 314, Type evaluates to vector140.
第三个参数确定字段的类型以及初始值。模板参数类型确定字段是标量字段、向量字段还是张量字段。当清单314中传递一个dimensionedVector时，类型的计算结果为vector140。

The fourth argument is a list of patch types, since we passed only one dimensioned value as the third argument, there has been no information passed on the boundary conditions of the field up to now. By passing the list of boundary types of the mixture velocity field (mixture.U()), the boundary conditions of the field Udm_ are specified.
第四个参数是面片类型的列表，因为我们只传递了一维值作为第三个参数，所以到目前为止还没有传递关于场的边界条件的信息。通过传递混合速度场的边界类型列表（mixture.U（）），指定了场Udm_2;的边界条件。

As there is no fifth argument passed in Listing 314, the return value of the call wordList() is used.
由于清单314中没有传递第五个参数，因此使用了call wordList（）的返回值。

##### 48.4.2 simple模型
The model named simple is similar to the model used by Brennan [12] with attribution to Dahl [17]. This model is very similar to the Vesilind [65] model (158), Brennan [12] explains the change of the base from the Euler number e to the base 10 with a closer fit to experimental data gathered by Dahl [17].
名为simple的模型类似于Brennan[12]使用的模型，归因于Dahl[17]。该模型与Vesilind[65]模型（158）非常相似，Brennan[12]解释了基数从Euler数e到基数10的变化，更接近Dahl[17]收集的实验数据。
vs = v0 10−kα (157)
The implementation of the simple model is more or less a direct translation from math (157) to C++. In the exponent the maximum of the dispersed volume fraction and zero is taken to avoid numerical trouble from negative values of the volume fraction. Reversing the sign in an exponent is never a good idea in numerical simulation.
简单模型的实现或多或少是直接从数学（157）到C++的转换。在指数中取离散体积分数的最大值和零，避免了体积分数负值带来的数值麻烦。在数值模拟中，反转指数的符号从来不是一个好主意。

```
 void Foam :: relativeVelocityModels :: simple :: correct ()
 { 
	  Udm_ = ( rhoc_ / rho () )* V0_ * pow ( scalar (10) , -a_ * max ( alphad_ , scalar (0) )) ;
 }
```
Listing 316: The calculation of the dispersed diffusion velocity Udm_ by the simple relative velocity
清单316：通过简单相对速度计算弥散扩散速度Udm

##### 48.4.3 general模型
The model referred to as general is most probably basedon the model of Takács [59], there is no reference to any literature in the header file. The Takács [59] model (159) is a so-called double-exponential model based on the model of Vesilind [65], see (158) [28, 12].
被称为general的模型很可能是基于Takács的模型[59]，头文件中没有引用任何文献。Takács[59]模型（159）是基于Vesilind[65]模型的所谓双指数模型，见（158）[28，12]。

vs = v0 e−nX (158)
vs = v0 

with
vs settling velocity
v0 maximum settling velocity
n model parameter
rh settling parameter for hindered settling
rp settling parameter for low solids concentration
X suspended solids concentration
vs沉降速度

v0最大沉降速度

n模型参数

阻碍沉降的rh沉降参数

低固相浓度下的rp沉降参数

X悬浮固体浓度
(160)

The implementation .
实现如下：
```
 void Foam :: relativeVelocityModels :: general :: correct ()
 { 
	  Udm_ =
 ( rhoc_ / rho () )
 * V0_
 *(
 exp (- a_ * max ( alphad_ - residualAlpha_ , scalar (0) ))
 - exp (- a1_ * max ( alphad_ - residualAlpha_ , scalar (0) ))
 );
 }
```
Listing 317: The calculation of the dispersed diffusion velocity Udm_ by the general relative velocity model.
清单317：用一般相对速度模型计算弥散扩散速度Udm。

#### 48.5 settlingFoam
Here we take a closer look on settlingFoam (of OpenFOAM-2.2.x), which is the predecessor of driftFluxFoam. By comparing the implementations of these two solvers we can observe the transition of the OpenFOAM source code base to a more encapsulated approach.
在这里，我们将更仔细地了解沉降泡沫（OpenFOAM-2.2.x的版本），它是floftfluxfoam的前身。通过比较这两个解算器的实现，我们可以观察到OpenFOAM源代码库向更封装的方法的转变。

##### 48.5.1 Mixture viscosity 混合物粘度
settlingFoam was/is restricted to the plastic or Bingham viscosity models. Listing 318 shows the code of settlingFoam, which computes the mixture viscosity. This code is located in a source file, which is included into the body of the PIMPLE loop of the solver.

沉降泡沫仅限于塑料或宾汉粘度模型。清单318显示了沉降泡沫的代码，它计算混合物的粘度。此代码位于源文件中，源文件包含在解算器的PIMPLE循环体中。
Thus, for this solver, the treatment of mixture viscosity is not encapsulated. The viscosity models are not located in separate files and the code of the solver itself contains all the knowledge of the viscosity models. Extending the solver with one or more mixture viscosity models would entail building an extended if-cascade within the file correctViscosity.H.
因此，对于该解算器，不封装混合物粘度的处理。粘度模型不在单独的文件中，求解器本身的代码包含粘度模型的所有知识。用一个或多个混合粘度模型扩展解算器需要在correctVisity.H文件中构建扩展的if级联。

```
 { 
	  /* compute plastic viscosity */
 mul = muc +
 plasticViscosity
 ( 
	  /* code removed for brevity */
 );
 if ( BinghamPlastic )
 {
 volScalarField tauy = yieldStress
 (
 /* see yieldStress .H */
 );
 mul =
 /* compute contribution of yield stress */
 + mul ;
 }

 mul = min ( mul , muMax ) ;
 }
```
Listing 318: The calculation of the mixture viscosity in the file correctViscosity.H of settlingFoam of OpenFOAM-2.2.x. Comments added by the author.
清单318:OpenFOAM-2.2.x的settingfoam文件correctVisity.H中混合物粘度的计算。作者补充的评论。

##### 48.5.2 Relative velocity models 相对速度模型
settlingFoam of OpenFOAM-2.2.x offers the same choice of relative velocity models as driftFluxFoam at the time of writing. However, implementation-wise we note, that model selection is, again, done in an if-statement cascade.
在撰写本文时，OpenFOAM-2.2.x的沉降泡沫提供了与driftFluxFoam相同的相对速度模型选择。然而，在实现方面，我们注意到，模型选择同样是在if语句级联中完成的。

```
 if ( VdjModel == " general ") 
  { 
	   Vdj = V0 *
 ( 
	  exp (-a * max ( alpha - alphaMin , scalar (0) ))
 - exp (- a1 * max ( alpha - alphaMin , scalar (0) ))
 );
  } 
   else if ( VdjModel == " simple ")
 {
 Vdj = V0 * pow (10.0 , -a * alpha );
 }
 else
 {
 FatalErrorIn ( args . executable () )
 << " Unknown VdjModel : " << VdjModel
 << abort ( FatalError ) ;
 }

 Vdj . correctBoundaryConditions () ;
```
Listing 319: The calculation of the relative velocity in the file calcVdj.H of settlingFoam of OpenFOAM-2.2.x.
清单319:OpenFOAM-2.2.x的文件calcVdj.H中沉降泡沫的相对速度的计算。

##### 48.5.3 Turbulence 湍流
Turbulence in settlingFoam was/is implemented in a similar fashion as in twoPhaseEulerFoam of that time. Both solvers feature a hard-coded k −  turbulence model, which is adapted to the solvers needs.
沉降泡沫中的湍流以与当时的两相规则泡沫相似的方式实现。两个解算器都具有硬编码的k− 湍流模型，适合解算器的需要。