34 Radiation modelling

Radiative heat transfer needs to be considered when temperatures are quite high. OpenFOAM offers several
models to account for radiative heat transfer: the discrete ordinates model (fvDOM), the P1 model and the
view factor model.

34.0.1 Solver control

The base class for all radiation models (radiationModel) provides controls on how often the radiation model
needs to be solved. Since the radiation models can be computationally quite expensive, and temperature changes
might be slower than the dynamics of the fluid flow, we may want to solve for radiation only every N-th time
step.

This is achieved by the entry for the solverFreq keyword in the file radiationProperties dictionary. This
keyword expects an integer value, which defaults to 1, and is also bounded to be at least 1 to prevent mischief
caused by a user entering a negative value.
```
1 void Foam :: radiationModel :: initialise ()
2 {
3 solverFreq_ = max (1, lookupOrDefault <label >(" solverFreq ", 1));
4
5 absorptionEmission_ . reset
6 (
7 radiationModels :: absorptionEmissionModel :: New (* this , mesh_ ). ptr ()
8 );
9
10 scatter_ . reset ( radiationModels :: scatterModel :: New (* this , mesh_ ). ptr ());
11
12 soot_ . reset ( radiationModels :: sootModel :: New (* this , mesh_ ).ptr ());
13 }
Listing 221: The initialise() method of the radiationModel class.
```

34.0.2 Radiative heat flux
Each of the radiation models writes, among other fields, the total radiative heat flux qr to disk. The signconvention
for the radiative heat flux is such97, that it is positive, when the surface absorbes the heat flux. This
is in line with the sign-convention for face normal vectors on a patch.

However, the convention for the wall heat flux, which is determined by a function object of that name is
opposite. With the wallHeatFlux function object, a positive heat flux means that the heat flows from the wall
into the domain.

34.1 Discrete ordinates - fvDOM

In OpenFOAM, the discrete ordinates (DO) model is named fvDOM. The eponymous discrete ordinates are a
finite number of spatial directions, along which radiative heat transport is solved for. Listing 222 shows the
diagnostic output of the model’s constructor listing these directions.
```
fvDOM : Created 60 rays with average directions ( dAve ) and solid angles ( omega )
Ray I0: dAve = (0.010235 0.0381976 0.0904495) , omega = 0.0999985
Ray I1: dAve = (0.0279626 0.0279626 0.0904495) , omega = 0.0999985
Ray I2: dAve = (0.0381976 0.010235 0.0904495) , omega = 0.0999985
Ray I3: dAve = (0.0381976 -0.010235 0.0904495) , omega = 0.0999985
Ray I4: dAve = (0.0279626 -0.0279626 0.0904495) , omega = 0.0999985
```
Listing 222: The constructor of the fvDOM radiation model is reporting the discretized directions for radiative
heat transport.

Each direction has its own radiative intensity field named ILambda_XX_YY, which has two suffixes: the first
(XX) is a counter for the direction, and the second suffix (YY) is a counter for the wavelength band. Listing 223
shows an example of this naming scheme, which is taken from OpenFOAM’s tutorials. In this specific case, we
solve for 60 discrete ordinates, which is indicated in Listing 222, and for a single wavelength band. Thus, the
first suffix runs from 0 to 59; and the second counter has only the value 0.

Since specifying identical BCs for each of the dozens of radiative intensity fields, the fvDOM model offers
the possibility to specify BCs using a field named IDefault, which applies to all the fields.
```
Time = 910
DILUPBiCGStab : Solving for Ux , Initial residual = 0.000484957 , Final residual = 8.59355e -07 , No Iterations 1
DILUPBiCGStab : Solving for Uy , Initial residual = 0.000636378 , Final residual = 1.3728e -06 , No Iterations 1
DILUPBiCGStab : Solving for Uz , Initial residual = 0.00100732 , Final residual = 1.64924e -06 , No Iterations 1
DILUPBiCGStab : Solving for h, Initial residual = 0.000646664 , Final residual = 9.12454e -07 , No Iterations 1
Radiation solver iter : 0
GAMG : Solving for ILambda_0_0 , Initial residual = 0.000289555 , Final residual = 7.99208e -16 , No Iterations 1
GAMG : Solving for ILambda_1_0 , Initial residual = 0.000281662 , Final residual = 7.86555e -16 , No Iterations 1
GAMG : Solving for ILambda_2_0 , Initial residual = 0.00028829 , Final residual = 7.91439e -16 , No Iterations 1
...
GAMG : Solving for ILambda_59_0 , Initial residual = 0.00312848 , Final residual = 2.98335e -06 , No Iterations 1
DICPCG : Solving for p_rgh , Initial residual = 0.00253219 , Final residual = 2.296e -05 , No Iterations 35
time step continuity errors : sum local = 1.18082e -06 , global = 1.41217e -19 , cumulative = -7.81505e -19
rho max / min : 1.16452 0.69867
DILUPBiCGStab : Solving for epsilon , Initial residual = 0.000330527 , Final residual = 6.62334e -06 , No Iterations 1
DILUPBiCGStab : Solving for k, Initial residual = 0.000939773 , Final residual = 1.06366e -05 , No Iterations 1
ExecutionTime = 654.13 s ClockTime = 655 s
```
Listing 223: An extract of the solver output when using the fvDOM radiation model. The solver output for the
radiation model follows the output of the solution for the momentum and energy equations. For each of the
discrete ordiantes a transport equation for the radiative intensity is solved.

When the solver writes a time step to disk, the radiative intensity field for each discrete ordiante is written
into the time step folder. The fvDOM radiation model also writes some additional fields to disk, which are
according to the description in the header file of the fvDOM model:

a Total absorption coefficient [1/m]

G Incident radiation [W/m^2]
qin Incident radiative heat flux [W/m^2]
qem Emitted radiative heat flux [W/m^2]
qr Total radiative heat flux [W/m^2]
34.2 P1

The P1 model is suited for optically thick problems, i.e. the medium through which the radiation is passing
through does absorb or scatter some of the incident radiation.

34.3 View factor

The viewFactor model has been released with OpenFOAM-2.0.098. This model only considers radiative heat
transfer between surfaces. Thus, this model is suitable for simulation cases with vacuum between hot surfaces, or
for cases with non-participating gases. Non-participating gases do neither absorb nor scatter thermal radiation.
Such gases are mono-atomic gases, such as argon or helium, or symmetric diatomic gases, such as oxygen,
nitrogen or hydrogen [15, 29].

The anouncement in the release notes of OpenFOAM-2.0.0 has the following to say about this model:
>... view factor model for radiative heat transfer, specifically between surfaces. The method begins with the generation of rays between discrete faces of the surfaces, using the viewFactorsGen utility in OpenFOAM. Radiative heat transfer is then calculated by summing energy exchanges between ray end-points. A major benefit of this approach is that energy is only exchanged between parts of surface that are directly visible to one another, giving a representative solution to complex problems where some surfaces are shielded from radiative sources by others.

The view factor model is also referred to as surface-to-surface (S2S) model, e.g. in Fluent [7].

34.3.1 Pre-processing

The viewFactor model requires some pre-processing, which is a 2 step process that involves the following
pre-processing tools:

faceAgglomerate

The anouncement of the viewFactor model in the release notes of OpenFOAM-2.0.0 has the following to say about the computational requirements of the viewFactor model:

>The computational time and memory requirement of the modelling is largely determined by the number of faces from which the rays emanate. In OpenFOAM, the cost can be reduced by grouping
faces together using the faceAgglomerate pre-processing utility.

Hence, the faceAgglomerate tool is used in preparation to create a coarser representation of the surface to reduce
computational effort. In Fluent, using face agglomeration to reduce the computational effort is referred to as
clustering [7].

viewFactorsGen

This tool does the actual creation of rays between the involved surfaces, respecively it computes the view factors
between the agglomerated faces.

Figure 87: The result of faceAgglomerate and viewFactorGen applied to a slightly refined cavity case. The
patches movingWall and fixedWalls have both been agglomerated, i.e. for the purposes of computing the view
factor, several faces of a patch form a coarsened face. This is evident from the visualisation of the rays created
by viewFactorGen, each bundle of rays starts from the center of such a coarsened face. The colour of the rays
is a mere ID, not the actual view factor.
34.3.2 Visualising the pre-processing results
Inspecting the results of the pre-processing steps can be quite important, see Section 34.3.5. Also, you might
wonder how Figure 87 was created.
Write the face-agglomeration
Enabling the writeFacesAgglomeration switch in the viewFactorDict dictionary causes faceAgglomerate
to write a field named facesAgglomeration, which contains a trivial internal field, yet the boundary values
correspond to a running index of the agglomerates. I.e. all faces with the value X belong to the agglomerate X.
Dump the rays
Enabling the dumpRays switch in the viewFactorDict dictionary causes viewFactorsGen to write a file named
allVisibleFaces.vtk, which contains the rays from each agglomerate to all other agglomerates. These rays
are shown in Figure 87 as lines connecting all agglomerates with each other.
34.3.3 Model use
The viewFactor model requires an additional field in the case setup, the new radiative heat flux qr. The unit
of qr is given in the header description of the viewFactor model as W/m2. In the field definition of qr, the
dimension set corresponds to the unit kg/s3, which works out to be the same unit once the unit Watt is replaced
by its SI representation.
The model furthermore reads the finalAgglom field, which is created by the faceAgglomerate tool.
34.3.4 Solution procedure
Once the view factors are determined by the pre-processing tools, the model can be used in a simulation. The
viewFactor model essentially boils down to an algebraic equation linking the net radiative heat flux with the
surface temperature via the view factors and other properties.
The model equation underlying the viewFactor model is the following:

Cijqi = bi (50)

ij
1
Ej
− ( 1
Ej
− 1)Fij

qi = (deltaij − Fij) T4
i (51)
With a static mesh, the view factors are constant, and the only major task for the viewFactor model is to
compute the inverse of an N × N matrix C, with N being the number of coarsened faces. As C contains only
constant entries, the inversion only needs to be done once, at the first iteration of the solver.
Thus, for big simulation cases, we can expect the viewFactor model to take long during pre-processing,
especially when creating the rays using viewFactorGen; and it will take especially long, when it computes the
inverse of C during the first iteration. This is compounded by the fact, that the computation of the radiative
flux happens on the master-process, i.e. parallelisation does not accelerate the viewFactor model, since the
major computational work is done by a single process.
Afterwards, howewer, the viewFactor model doesn’t incur significant computational effort anymore, since
the inverse of C is cached, and during each iteration, computing the radiative heat flux reduces to a simple
matrix-vector multiplication. With a cached inverse matrix, we can solve Eq. (50) very efficiently over and
over, since only the RHS changes from time step to time step.
The discussion above, about the computational effort, can be better understood if we take a look at the
relevant code, shown in Listing 224. There, we see that the viewFactor model is only then efficient, when the
emissivities are constant, otherwise we are not able to benefit from caching the inverse of the matrix C, since
it would change from time step to time step.
1 if ( Pstream :: master ())
2 {
3 // Variable emissivity
4 if (! constEmissivity_ )
5 {
6 scalarSquareMatrix C( totalNCoarseFaces_ , 0.0) ;
7
8 // build equation system - code removed for brevity
9
10 Info << "\ nSolving view factor equations ... " << endl ;
11 // Negative coming into the fluid
12 LUsolve (C, q);
13 }
14 else // Constant emissivity
15 {
16 // Initial iter calculates CLU and chaches it
17 if ( iterCounter_ == 0)
18 {
19 // build equation system - code removed for brevity
20
21 if ( debug )
22 {
23 InfoInFunction
24 << "\ nDecomposing C matrix ... " << endl ;
25 }
26 LUDecompose ( CLU_ () , pivotIndices_ );
27 }
28
29 // build equation system - code removed for brevity
30
31 if ( debug )
32 {
33 InfoInFunction
34 << "\ nLU Back substitute C matrix .." << endl ;
35 }
36 LUBacksubstitute ( CLU_ () , pivotIndices_ , q);
37 iterCounter_ ++;
38 }
39 }
Listing 224: A snippet of the calculate() method of the viewFactor model.

Figure 88: One of the aggressively agglomerated faces: On the right boundary the temperature is 300 K, yet the
radiative heat-flux computed by the mean temperature cools the solid down to 165 K, which is very unphysical
for a case that computes a heated solid interacting with a body of gas. No cooling should occur at all.
34.3.5 Pitfall: too aggressive faceAgglomeration
The pre-processing operation of face-agglomeration is an important one, since it reduces the computational effort
for computing the view-factors by orders of magnitude. However, don’t be too aggresive with face-agglomeration,
at least in regions in which you expect large temperature gradients.
In Figure 88 we see the result of an overly aggresive agglomeration, aggromeration if you like. The case in
question is a solid which is volumetrically heated by Joule heating, i.e. an electrical current passing through
the solid. The solid is embedded in a fluid region with a gas (nitrogen) as working fluid. The large agglomerate
causes the radiative heat transfer locally to be under- or overestimated. In regions colder than the mean
temperature of the agglomerate, the radiative heat transfer acts to cool the local cells. In regions hotter than
the mean temperature of the agglomerate, the heat transfer is underestimated, thus, these regions get hotter
than they ought to be.
Always check the face-agglomeration, i.e. view it in ParaView and judge whether it is fine enough in regions
where you expect temperature gradients, as the radiative heat-transfer depends on the fourth power of the
temperature, even a moderate within an agglomerate can lead to great error.